{"ast":null,"code":"// @ts-check\n\n/**\n * @typedef {{\n *       type: 'file';\n *       file: File;\n *       fullPath?: string;\n *     }\n *   | {\n *       type: 'url';\n *       url: string;\n *     }} DropItem\n */\n\n/**\n * @param {File} file\n * @returns {Promise<boolean>}\n */\nfunction checkIsDirectory(file) {\n  return new Promise(resolve => {\n    if (typeof window.FileReader !== 'function') {\n      resolve(false);\n    }\n    try {\n      let reader = new FileReader();\n      reader.onerror = () => {\n        resolve(true);\n      };\n      /** @param {Event} e */\n      let onLoad = e => {\n        if (e.type !== 'loadend') {\n          reader.abort();\n        }\n        resolve(false);\n      };\n      reader.onloadend = onLoad;\n      reader.onprogress = onLoad;\n      reader.readAsDataURL(file);\n    } catch (err) {\n      resolve(false);\n    }\n  });\n}\n\n/**\n * @param {FileSystemEntry} webkitEntry\n * @param {string} dataTransferItemType\n * @returns {Promise<DropItem[] | null>}\n */\nfunction readEntryContentAsync(webkitEntry, dataTransferItemType) {\n  return new Promise(resolve => {\n    let reading = 0;\n    /** @type {DropItem[]} */\n    const dropItems = [];\n\n    /** @param {FileSystemEntry} entry */\n    const readEntry = entry => {\n      if (!entry) {\n        console.warn('Unexpectedly received empty content entry', {\n          scope: 'drag-and-drop'\n        });\n        resolve(null);\n      }\n      if (entry.isFile) {\n        reading++;\n        /** @type {FileSystemFileEntry} */\n        entry.file(file => {\n          reading--;\n          // webkitGetAsEntry don't provide type for HEIC images at least, so we use type value from dataTransferItem\n          const clonedFile = new File([file], file.name, {\n            type: file.type || dataTransferItemType\n          });\n          dropItems.push({\n            type: 'file',\n            file: clonedFile,\n            fullPath: entry.fullPath\n          });\n          if (reading === 0) {\n            resolve(dropItems);\n          }\n        });\n      } else if (entry.isDirectory) {\n        readReaderContent(/** @type {FileSystemDirectoryEntry} */entry.createReader());\n      }\n    };\n\n    /** @param {FileSystemDirectoryReader} reader */\n    let readReaderContent = reader => {\n      reading++;\n      reader.readEntries(entries => {\n        reading--;\n        for (let entry of entries) {\n          readEntry(entry);\n        }\n        if (reading === 0) {\n          resolve(dropItems);\n        }\n      });\n    };\n    readEntry(webkitEntry);\n  });\n}\n\n/**\n * Note: dataTransfer will be destroyed outside of the call stack. So, do not try to process it asynchronous.\n *\n * @param {DataTransfer} dataTransfer\n * @returns {Promise<DropItem[]>}\n */\nexport function getDropItems(dataTransfer) {\n  /** @type {DropItem[]} */\n  const dropItems = [];\n  const promises = [];\n  for (let i = 0; i < dataTransfer.items.length; i++) {\n    let item = dataTransfer.items[i];\n    if (!item) {\n      continue;\n    }\n    if (item.kind === 'file') {\n      const itemType = item.type;\n      if (typeof item.webkitGetAsEntry === 'function' || typeof (/** @type {any} */item.getAsEntry) === 'function') {\n        let entry = typeof item.webkitGetAsEntry === 'function' ? item.webkitGetAsEntry() : /** @type {any} */item.getAsEntry();\n        promises.push(readEntryContentAsync(entry, itemType).then(items => {\n          if (items) {\n            dropItems.push(...items);\n          }\n        }));\n        continue;\n      }\n      const file = item.getAsFile();\n      file && promises.push(checkIsDirectory(file).then(isDirectory => {\n        if (isDirectory) {\n          // we can't get directory files, so we'll skip it\n        } else {\n          dropItems.push({\n            type: 'file',\n            file\n          });\n        }\n      }));\n    } else if (item.kind === 'string' && item.type.match('^text/uri-list')) {\n      promises.push(new Promise(resolve => {\n        item.getAsString(value => {\n          dropItems.push({\n            type: 'url',\n            url: value\n          });\n          resolve(undefined);\n        });\n      }));\n    }\n  }\n  return Promise.all(promises).then(() => dropItems);\n}","map":{"version":3,"names":["checkIsDirectory","file","Promise","resolve","window","FileReader","reader","onerror","onLoad","e","type","abort","onloadend","onprogress","readAsDataURL","err","readEntryContentAsync","webkitEntry","dataTransferItemType","reading","dropItems","readEntry","entry","console","warn","scope","isFile","clonedFile","File","name","push","fullPath","isDirectory","readReaderContent","createReader","readEntries","entries","getDropItems","dataTransfer","promises","i","items","length","item","kind","itemType","webkitGetAsEntry","getAsEntry","then","getAsFile","match","getAsString","value","url","undefined","all"],"sources":["/Users/kavinth/Documents/GitHub/Smart-Alert/Smart-Alert-new/frontend/node_modules/@uploadcare/file-uploader/blocks/DropArea/getDropItems.js"],"sourcesContent":["// @ts-check\n\n/**\n * @typedef {{\n *       type: 'file';\n *       file: File;\n *       fullPath?: string;\n *     }\n *   | {\n *       type: 'url';\n *       url: string;\n *     }} DropItem\n */\n\n/**\n * @param {File} file\n * @returns {Promise<boolean>}\n */\nfunction checkIsDirectory(file) {\n  return new Promise((resolve) => {\n    if (typeof window.FileReader !== 'function') {\n      resolve(false);\n    }\n\n    try {\n      let reader = new FileReader();\n      reader.onerror = () => {\n        resolve(true);\n      };\n      /** @param {Event} e */\n      let onLoad = (e) => {\n        if (e.type !== 'loadend') {\n          reader.abort();\n        }\n        resolve(false);\n      };\n      reader.onloadend = onLoad;\n      reader.onprogress = onLoad;\n\n      reader.readAsDataURL(file);\n    } catch (err) {\n      resolve(false);\n    }\n  });\n}\n\n/**\n * @param {FileSystemEntry} webkitEntry\n * @param {string} dataTransferItemType\n * @returns {Promise<DropItem[] | null>}\n */\nfunction readEntryContentAsync(webkitEntry, dataTransferItemType) {\n  return new Promise((resolve) => {\n    let reading = 0;\n    /** @type {DropItem[]} */\n    const dropItems = [];\n\n    /** @param {FileSystemEntry} entry */\n    const readEntry = (entry) => {\n      if (!entry) {\n        console.warn('Unexpectedly received empty content entry', { scope: 'drag-and-drop' });\n        resolve(null);\n      }\n      if (entry.isFile) {\n        reading++;\n        /** @type {FileSystemFileEntry} */ (entry).file((file) => {\n          reading--;\n          // webkitGetAsEntry don't provide type for HEIC images at least, so we use type value from dataTransferItem\n          const clonedFile = new File([file], file.name, { type: file.type || dataTransferItemType });\n          dropItems.push({\n            type: 'file',\n            file: clonedFile,\n            fullPath: entry.fullPath,\n          });\n\n          if (reading === 0) {\n            resolve(dropItems);\n          }\n        });\n      } else if (entry.isDirectory) {\n        readReaderContent(/** @type {FileSystemDirectoryEntry} */ (entry).createReader());\n      }\n    };\n\n    /** @param {FileSystemDirectoryReader} reader */\n    let readReaderContent = (reader) => {\n      reading++;\n\n      reader.readEntries((entries) => {\n        reading--;\n        for (let entry of entries) {\n          readEntry(entry);\n        }\n\n        if (reading === 0) {\n          resolve(dropItems);\n        }\n      });\n    };\n\n    readEntry(webkitEntry);\n  });\n}\n\n/**\n * Note: dataTransfer will be destroyed outside of the call stack. So, do not try to process it asynchronous.\n *\n * @param {DataTransfer} dataTransfer\n * @returns {Promise<DropItem[]>}\n */\nexport function getDropItems(dataTransfer) {\n  /** @type {DropItem[]} */\n  const dropItems = [];\n  const promises = [];\n  for (let i = 0; i < dataTransfer.items.length; i++) {\n    let item = dataTransfer.items[i];\n    if (!item) {\n      continue;\n    }\n    if (item.kind === 'file') {\n      const itemType = item.type;\n      if (typeof item.webkitGetAsEntry === 'function' || typeof (/** @type {any} */ (item).getAsEntry) === 'function') {\n        let entry =\n          typeof item.webkitGetAsEntry === 'function'\n            ? item.webkitGetAsEntry()\n            : /** @type {any} */ (item).getAsEntry();\n        promises.push(\n          readEntryContentAsync(entry, itemType).then((items) => {\n            if (items) {\n              dropItems.push(...items);\n            }\n          }),\n        );\n        continue;\n      }\n\n      const file = item.getAsFile();\n      file &&\n        promises.push(\n          checkIsDirectory(file).then((isDirectory) => {\n            if (isDirectory) {\n              // we can't get directory files, so we'll skip it\n            } else {\n              dropItems.push({\n                type: 'file',\n                file,\n              });\n            }\n          }),\n        );\n    } else if (item.kind === 'string' && item.type.match('^text/uri-list')) {\n      promises.push(\n        new Promise((resolve) => {\n          item.getAsString((value) => {\n            dropItems.push({\n              type: 'url',\n              url: value,\n            });\n            resolve(undefined);\n          });\n        }),\n      );\n    }\n  }\n\n  return Promise.all(promises).then(() => dropItems);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}