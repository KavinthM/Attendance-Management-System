{"ast":null,"code":"// @ts-check\nimport { getPluralForm } from './getPluralForm.js';\nconst BASE = 1000;\nexport const ByteUnitEnum = Object.freeze({\n  AUTO: 'auto',\n  BYTE: 'byte',\n  KB: 'kb',\n  MB: 'mb',\n  GB: 'gb',\n  TB: 'tb',\n  PB: 'pb'\n});\n\n/**\n * Round a specified number to decimal with two places. Round to larger value, because basically we use it for usage and\n * we charge customers for 1 GB even he consumed 1 byte. Feature limits are usually specified in exact MB/GB/TB, so they\n * will not be rounded.\n *\n * @param {number} number\n * @returns {number}\n */\nconst round = number => Math.ceil(number * 100) / 100;\n\n/**\n * @param {number} bytes\n * @param {(typeof ByteUnitEnum)[keyof typeof ByteUnitEnum]} unit\n * @returns {string}\n */\nexport const prettyBytes = (bytes, unit = ByteUnitEnum.AUTO) => {\n  const isAutoMode = unit === ByteUnitEnum.AUTO;\n  if (unit === ByteUnitEnum.BYTE || isAutoMode && bytes < BASE ** 1) {\n    // TODO: handle blocks locale\n    const pluralForm = /** @type {Extract<import('./getPluralForm').PluralForm, 'one' | 'other'>} */\n    getPluralForm('en-US', bytes);\n    const pluralized = {\n      one: 'byte',\n      other: 'bytes'\n    }[pluralForm];\n    return `${bytes} ${pluralized}`;\n  }\n  if (unit === ByteUnitEnum.KB || isAutoMode && bytes < BASE ** 2) {\n    return `${round(bytes / BASE ** 1)} KB`;\n  }\n  if (unit === ByteUnitEnum.MB || isAutoMode && bytes < BASE ** 3) {\n    return `${round(bytes / BASE ** 2)} MB`;\n  }\n  if (unit === ByteUnitEnum.GB || isAutoMode && bytes < BASE ** 4) {\n    return `${round(bytes / BASE ** 3)} GB`;\n  }\n  if (unit === ByteUnitEnum.TB || isAutoMode && bytes < BASE ** 5) {\n    return `${round(bytes / BASE ** 4)} TB`;\n  }\n  return `${round(bytes / BASE ** 5)} PB`;\n};","map":{"version":3,"names":["getPluralForm","BASE","ByteUnitEnum","Object","freeze","AUTO","BYTE","KB","MB","GB","TB","PB","round","number","Math","ceil","prettyBytes","bytes","unit","isAutoMode","pluralForm","pluralized","one","other"],"sources":["/Users/kavinth/Documents/GitHub/Smart-Alert/Smart-Alert-new/frontend/node_modules/@uploadcare/file-uploader/utils/prettyBytes.js"],"sourcesContent":["// @ts-check\nimport { getPluralForm } from './getPluralForm.js';\n\nconst BASE = 1000;\n\nexport const ByteUnitEnum = Object.freeze({\n  AUTO: 'auto',\n  BYTE: 'byte',\n  KB: 'kb',\n  MB: 'mb',\n  GB: 'gb',\n  TB: 'tb',\n  PB: 'pb',\n});\n\n/**\n * Round a specified number to decimal with two places. Round to larger value, because basically we use it for usage and\n * we charge customers for 1 GB even he consumed 1 byte. Feature limits are usually specified in exact MB/GB/TB, so they\n * will not be rounded.\n *\n * @param {number} number\n * @returns {number}\n */\nconst round = (number) => Math.ceil(number * 100) / 100;\n\n/**\n * @param {number} bytes\n * @param {(typeof ByteUnitEnum)[keyof typeof ByteUnitEnum]} unit\n * @returns {string}\n */\nexport const prettyBytes = (bytes, unit = ByteUnitEnum.AUTO) => {\n  const isAutoMode = unit === ByteUnitEnum.AUTO;\n\n  if (unit === ByteUnitEnum.BYTE || (isAutoMode && bytes < BASE ** 1)) {\n    // TODO: handle blocks locale\n    const pluralForm = /** @type {Extract<import('./getPluralForm').PluralForm, 'one' | 'other'>} */ (\n      getPluralForm('en-US', bytes)\n    );\n    const pluralized = {\n      one: 'byte',\n      other: 'bytes',\n    }[pluralForm];\n\n    return `${bytes} ${pluralized}`;\n  }\n\n  if (unit === ByteUnitEnum.KB || (isAutoMode && bytes < BASE ** 2)) {\n    return `${round(bytes / BASE ** 1)} KB`;\n  }\n\n  if (unit === ByteUnitEnum.MB || (isAutoMode && bytes < BASE ** 3)) {\n    return `${round(bytes / BASE ** 2)} MB`;\n  }\n\n  if (unit === ByteUnitEnum.GB || (isAutoMode && bytes < BASE ** 4)) {\n    return `${round(bytes / BASE ** 3)} GB`;\n  }\n\n  if (unit === ByteUnitEnum.TB || (isAutoMode && bytes < BASE ** 5)) {\n    return `${round(bytes / BASE ** 4)} TB`;\n  }\n\n  return `${round(bytes / BASE ** 5)} PB`;\n};\n"],"mappings":"AAAA;AACA,SAASA,aAAa,QAAQ,oBAAoB;AAElD,MAAMC,IAAI,GAAG,IAAI;AAEjB,OAAO,MAAMC,YAAY,GAAGC,MAAM,CAACC,MAAM,CAAC;EACxCC,IAAI,EAAE,MAAM;EACZC,IAAI,EAAE,MAAM;EACZC,EAAE,EAAE,IAAI;EACRC,EAAE,EAAE,IAAI;EACRC,EAAE,EAAE,IAAI;EACRC,EAAE,EAAE,IAAI;EACRC,EAAE,EAAE;AACN,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,KAAK,GAAIC,MAAM,IAAKC,IAAI,CAACC,IAAI,CAACF,MAAM,GAAG,GAAG,CAAC,GAAG,GAAG;;AAEvD;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,WAAW,GAAGA,CAACC,KAAK,EAAEC,IAAI,GAAGhB,YAAY,CAACG,IAAI,KAAK;EAC9D,MAAMc,UAAU,GAAGD,IAAI,KAAKhB,YAAY,CAACG,IAAI;EAE7C,IAAIa,IAAI,KAAKhB,YAAY,CAACI,IAAI,IAAKa,UAAU,IAAIF,KAAK,GAAGhB,IAAI,IAAI,CAAE,EAAE;IACnE;IACA,MAAMmB,UAAU,GAAG;IACjBpB,aAAa,CAAC,OAAO,EAAEiB,KAAK,CAC7B;IACD,MAAMI,UAAU,GAAG;MACjBC,GAAG,EAAE,MAAM;MACXC,KAAK,EAAE;IACT,CAAC,CAACH,UAAU,CAAC;IAEb,OAAO,GAAGH,KAAK,IAAII,UAAU,EAAE;EACjC;EAEA,IAAIH,IAAI,KAAKhB,YAAY,CAACK,EAAE,IAAKY,UAAU,IAAIF,KAAK,GAAGhB,IAAI,IAAI,CAAE,EAAE;IACjE,OAAO,GAAGW,KAAK,CAACK,KAAK,GAAGhB,IAAI,IAAI,CAAC,CAAC,KAAK;EACzC;EAEA,IAAIiB,IAAI,KAAKhB,YAAY,CAACM,EAAE,IAAKW,UAAU,IAAIF,KAAK,GAAGhB,IAAI,IAAI,CAAE,EAAE;IACjE,OAAO,GAAGW,KAAK,CAACK,KAAK,GAAGhB,IAAI,IAAI,CAAC,CAAC,KAAK;EACzC;EAEA,IAAIiB,IAAI,KAAKhB,YAAY,CAACO,EAAE,IAAKU,UAAU,IAAIF,KAAK,GAAGhB,IAAI,IAAI,CAAE,EAAE;IACjE,OAAO,GAAGW,KAAK,CAACK,KAAK,GAAGhB,IAAI,IAAI,CAAC,CAAC,KAAK;EACzC;EAEA,IAAIiB,IAAI,KAAKhB,YAAY,CAACQ,EAAE,IAAKS,UAAU,IAAIF,KAAK,GAAGhB,IAAI,IAAI,CAAE,EAAE;IACjE,OAAO,GAAGW,KAAK,CAACK,KAAK,GAAGhB,IAAI,IAAI,CAAC,CAAC,KAAK;EACzC;EAEA,OAAO,GAAGW,KAAK,CAACK,KAAK,GAAGhB,IAAI,IAAI,CAAC,CAAC,KAAK;AACzC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}