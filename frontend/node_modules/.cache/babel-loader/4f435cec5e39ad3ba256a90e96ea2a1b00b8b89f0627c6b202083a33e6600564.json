{"ast":null,"code":"// @ts-check\n\nimport { isSecureTokenExpired } from '../utils/isSecureTokenExpired.js';\nexport class SecureUploadsManager {\n  /**\n   * @private\n   * @type {import('./UploaderBlock.js').UploaderBlock}\n   */\n  _block;\n  /**\n   * @private\n   * @type {import('../types').SecureUploadsSignatureAndExpire | null}\n   */\n  _secureToken = null;\n\n  /** @param {import('./UploaderBlock.js').UploaderBlock} block */\n  constructor(block) {\n    this._block = block;\n  }\n\n  /**\n   * @private\n   * @param {unknown[]} args\n   */\n  _debugPrint(...args) {\n    this._block.debugPrint('[secure-uploads]', ...args);\n  }\n\n  /** @returns {Promise<import('../types').SecureUploadsSignatureAndExpire | null>} */\n  async getSecureToken() {\n    const {\n      secureSignature,\n      secureExpire,\n      secureUploadsSignatureResolver\n    } = this._block.cfg;\n    if ((secureSignature || secureExpire) && secureUploadsSignatureResolver) {\n      console.warn('Both secureSignature/secureExpire and secureUploadsSignatureResolver are set. secureUploadsSignatureResolver will be used.');\n    }\n    if (secureUploadsSignatureResolver) {\n      if (!this._secureToken || isSecureTokenExpired(this._secureToken, {\n        threshold: this._block.cfg.secureUploadsExpireThreshold\n      })) {\n        if (!this._secureToken) {\n          this._debugPrint('Secure signature is not set yet.');\n        } else {\n          this._debugPrint('Secure signature is expired. Resolving a new one...');\n        }\n        try {\n          const result = await secureUploadsSignatureResolver();\n          if (!result) {\n            this._debugPrint('Secure signature resolver returned nothing.');\n            this._secureToken = null;\n          } else if (!result.secureSignature || !result.secureExpire) {\n            console.error('Secure signature resolver returned an invalid result:', result);\n          } else {\n            this._debugPrint('Secure signature resolved:', result);\n            this._debugPrint('Secure signature will expire in', new Date(Number(result.secureExpire) * 1000).toISOString());\n            this._secureToken = result;\n          }\n        } catch (err) {\n          console.error('Secure signature resolving failed. Falling back to the previous one.', err);\n        }\n      }\n      return this._secureToken;\n    }\n    if (secureSignature && secureExpire) {\n      this._debugPrint('Secure signature and expire are set. Using them...', {\n        secureSignature,\n        secureExpire\n      });\n      return {\n        secureSignature,\n        secureExpire\n      };\n    }\n    return null;\n  }\n}","map":{"version":3,"names":["isSecureTokenExpired","SecureUploadsManager","_block","_secureToken","constructor","block","_debugPrint","args","debugPrint","getSecureToken","secureSignature","secureExpire","secureUploadsSignatureResolver","cfg","console","warn","threshold","secureUploadsExpireThreshold","result","error","Date","Number","toISOString","err"],"sources":["/Users/kavinth/Documents/GitHub/Smart-Alert/Smart-Alert-new/frontend/node_modules/@uploadcare/file-uploader/abstract/SecureUploadsManager.js"],"sourcesContent":["// @ts-check\n\nimport { isSecureTokenExpired } from '../utils/isSecureTokenExpired.js';\n\nexport class SecureUploadsManager {\n  /**\n   * @private\n   * @type {import('./UploaderBlock.js').UploaderBlock}\n   */\n  _block;\n  /**\n   * @private\n   * @type {import('../types').SecureUploadsSignatureAndExpire | null}\n   */\n  _secureToken = null;\n\n  /** @param {import('./UploaderBlock.js').UploaderBlock} block */\n  constructor(block) {\n    this._block = block;\n  }\n\n  /**\n   * @private\n   * @param {unknown[]} args\n   */\n  _debugPrint(...args) {\n    this._block.debugPrint('[secure-uploads]', ...args);\n  }\n\n  /** @returns {Promise<import('../types').SecureUploadsSignatureAndExpire | null>} */\n  async getSecureToken() {\n    const { secureSignature, secureExpire, secureUploadsSignatureResolver } = this._block.cfg;\n\n    if ((secureSignature || secureExpire) && secureUploadsSignatureResolver) {\n      console.warn(\n        'Both secureSignature/secureExpire and secureUploadsSignatureResolver are set. secureUploadsSignatureResolver will be used.',\n      );\n    }\n\n    if (secureUploadsSignatureResolver) {\n      if (\n        !this._secureToken ||\n        isSecureTokenExpired(this._secureToken, { threshold: this._block.cfg.secureUploadsExpireThreshold })\n      ) {\n        if (!this._secureToken) {\n          this._debugPrint('Secure signature is not set yet.');\n        } else {\n          this._debugPrint('Secure signature is expired. Resolving a new one...');\n        }\n        try {\n          const result = await secureUploadsSignatureResolver();\n          if (!result) {\n            this._debugPrint('Secure signature resolver returned nothing.');\n            this._secureToken = null;\n          } else if (!result.secureSignature || !result.secureExpire) {\n            console.error('Secure signature resolver returned an invalid result:', result);\n          } else {\n            this._debugPrint('Secure signature resolved:', result);\n            this._debugPrint(\n              'Secure signature will expire in',\n              new Date(Number(result.secureExpire) * 1000).toISOString(),\n            );\n            this._secureToken = result;\n          }\n        } catch (err) {\n          console.error('Secure signature resolving failed. Falling back to the previous one.', err);\n        }\n      }\n\n      return this._secureToken;\n    }\n\n    if (secureSignature && secureExpire) {\n      this._debugPrint('Secure signature and expire are set. Using them...', {\n        secureSignature,\n        secureExpire,\n      });\n\n      return {\n        secureSignature,\n        secureExpire,\n      };\n    }\n\n    return null;\n  }\n}\n"],"mappings":"AAAA;;AAEA,SAASA,oBAAoB,QAAQ,kCAAkC;AAEvE,OAAO,MAAMC,oBAAoB,CAAC;EAChC;AACF;AACA;AACA;EACEC,MAAM;EACN;AACF;AACA;AACA;EACEC,YAAY,GAAG,IAAI;;EAEnB;EACAC,WAAWA,CAACC,KAAK,EAAE;IACjB,IAAI,CAACH,MAAM,GAAGG,KAAK;EACrB;;EAEA;AACF;AACA;AACA;EACEC,WAAWA,CAAC,GAAGC,IAAI,EAAE;IACnB,IAAI,CAACL,MAAM,CAACM,UAAU,CAAC,kBAAkB,EAAE,GAAGD,IAAI,CAAC;EACrD;;EAEA;EACA,MAAME,cAAcA,CAAA,EAAG;IACrB,MAAM;MAAEC,eAAe;MAAEC,YAAY;MAAEC;IAA+B,CAAC,GAAG,IAAI,CAACV,MAAM,CAACW,GAAG;IAEzF,IAAI,CAACH,eAAe,IAAIC,YAAY,KAAKC,8BAA8B,EAAE;MACvEE,OAAO,CAACC,IAAI,CACV,4HACF,CAAC;IACH;IAEA,IAAIH,8BAA8B,EAAE;MAClC,IACE,CAAC,IAAI,CAACT,YAAY,IAClBH,oBAAoB,CAAC,IAAI,CAACG,YAAY,EAAE;QAAEa,SAAS,EAAE,IAAI,CAACd,MAAM,CAACW,GAAG,CAACI;MAA6B,CAAC,CAAC,EACpG;QACA,IAAI,CAAC,IAAI,CAACd,YAAY,EAAE;UACtB,IAAI,CAACG,WAAW,CAAC,kCAAkC,CAAC;QACtD,CAAC,MAAM;UACL,IAAI,CAACA,WAAW,CAAC,qDAAqD,CAAC;QACzE;QACA,IAAI;UACF,MAAMY,MAAM,GAAG,MAAMN,8BAA8B,CAAC,CAAC;UACrD,IAAI,CAACM,MAAM,EAAE;YACX,IAAI,CAACZ,WAAW,CAAC,6CAA6C,CAAC;YAC/D,IAAI,CAACH,YAAY,GAAG,IAAI;UAC1B,CAAC,MAAM,IAAI,CAACe,MAAM,CAACR,eAAe,IAAI,CAACQ,MAAM,CAACP,YAAY,EAAE;YAC1DG,OAAO,CAACK,KAAK,CAAC,uDAAuD,EAAED,MAAM,CAAC;UAChF,CAAC,MAAM;YACL,IAAI,CAACZ,WAAW,CAAC,4BAA4B,EAAEY,MAAM,CAAC;YACtD,IAAI,CAACZ,WAAW,CACd,iCAAiC,EACjC,IAAIc,IAAI,CAACC,MAAM,CAACH,MAAM,CAACP,YAAY,CAAC,GAAG,IAAI,CAAC,CAACW,WAAW,CAAC,CAC3D,CAAC;YACD,IAAI,CAACnB,YAAY,GAAGe,MAAM;UAC5B;QACF,CAAC,CAAC,OAAOK,GAAG,EAAE;UACZT,OAAO,CAACK,KAAK,CAAC,sEAAsE,EAAEI,GAAG,CAAC;QAC5F;MACF;MAEA,OAAO,IAAI,CAACpB,YAAY;IAC1B;IAEA,IAAIO,eAAe,IAAIC,YAAY,EAAE;MACnC,IAAI,CAACL,WAAW,CAAC,oDAAoD,EAAE;QACrEI,eAAe;QACfC;MACF,CAAC,CAAC;MAEF,OAAO;QACLD,eAAe;QACfC;MACF,CAAC;IACH;IAEA,OAAO,IAAI;EACb;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}