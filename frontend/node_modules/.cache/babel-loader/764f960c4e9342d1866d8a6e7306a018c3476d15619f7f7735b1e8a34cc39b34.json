{"ast":null,"code":"// @ts-check\n\n/** @type {import('./types').InputMessageType[]} */\nconst MESSAGE_TYPE_WHITELIST = ['selected-files-change', 'toolbar-state-change'];\n\n/**\n * @param {unknown} message\n * @returns {message is import(\"./types\").InputMessageMap[import(\"./types\").InputMessageType]}\n */\nconst isWhitelistedMessage = message => {\n  if (!message) return false;\n  if (typeof message !== 'object') return false;\n  return 'type' in message && MESSAGE_TYPE_WHITELIST.includes(/** @type {import('./types').InputMessageType} */message.type);\n};\nexport class MessageBridge {\n  /** @type {Map<string, Set<import('./types').InputMessageHandler<import('./types').InputMessageType>>>} */\n  _handlerMap = new Map();\n\n  /** @type {Window} */\n  _context;\n\n  /** @param {Window} context */\n  constructor(context) {\n    this._context = context;\n    window.addEventListener('message', this._handleMessage);\n  }\n\n  /** @param {MessageEvent} e */\n  _handleMessage = e => {\n    if (e.source !== this._context) {\n      return;\n    }\n    const message = e.data;\n    if (!isWhitelistedMessage(message)) {\n      return;\n    }\n    const handlers = this._handlerMap.get(message.type);\n    if (handlers) {\n      for (const handler of handlers) {\n        handler(message);\n      }\n    }\n  };\n\n  /**\n   * @template {import('./types').InputMessageType} T\n   * @param {T} type\n   * @param {import('./types').InputMessageHandler<T>} handler\n   */\n  on(type, handler) {\n    const handlers = this._handlerMap.get(type) ?? new Set();\n    if (!this._handlerMap.has(type)) {\n      this._handlerMap.set(type, handlers);\n    }\n    handlers.add(/** @type {import('./types').InputMessageHandler<import('./types').InputMessageType>} */handler);\n  }\n\n  /** @param {import('./types').OutputMessage} message */\n  send(message) {\n    this._context.postMessage(message, '*');\n  }\n  destroy() {\n    window.removeEventListener('message', this._handleMessage);\n  }\n}","map":{"version":3,"names":["MESSAGE_TYPE_WHITELIST","isWhitelistedMessage","message","includes","type","MessageBridge","_handlerMap","Map","_context","constructor","context","window","addEventListener","_handleMessage","e","source","data","handlers","get","handler","on","Set","has","set","add","send","postMessage","destroy","removeEventListener"],"sources":["/Users/kavinth/Documents/GitHub/Smart-Alert/Smart-Alert-new/frontend/node_modules/@uploadcare/file-uploader/blocks/ExternalSource/MessageBridge.js"],"sourcesContent":["// @ts-check\n\n/** @type {import('./types').InputMessageType[]} */\nconst MESSAGE_TYPE_WHITELIST = ['selected-files-change', 'toolbar-state-change'];\n\n/**\n * @param {unknown} message\n * @returns {message is import(\"./types\").InputMessageMap[import(\"./types\").InputMessageType]}\n */\nconst isWhitelistedMessage = (message) => {\n  if (!message) return false;\n  if (typeof message !== 'object') return false;\n  return (\n    'type' in message &&\n    MESSAGE_TYPE_WHITELIST.includes(/** @type {import('./types').InputMessageType} */ (message.type))\n  );\n};\n\nexport class MessageBridge {\n  /** @type {Map<string, Set<import('./types').InputMessageHandler<import('./types').InputMessageType>>>} */\n  _handlerMap = new Map();\n\n  /** @type {Window} */\n  _context;\n\n  /** @param {Window} context */\n  constructor(context) {\n    this._context = context;\n\n    window.addEventListener('message', this._handleMessage);\n  }\n\n  /** @param {MessageEvent} e */\n  _handleMessage = (e) => {\n    if (e.source !== this._context) {\n      return;\n    }\n    const message = e.data;\n    if (!isWhitelistedMessage(message)) {\n      return;\n    }\n\n    const handlers = this._handlerMap.get(message.type);\n    if (handlers) {\n      for (const handler of handlers) {\n        handler(message);\n      }\n    }\n  };\n\n  /**\n   * @template {import('./types').InputMessageType} T\n   * @param {T} type\n   * @param {import('./types').InputMessageHandler<T>} handler\n   */\n  on(type, handler) {\n    const handlers = this._handlerMap.get(type) ?? new Set();\n    if (!this._handlerMap.has(type)) {\n      this._handlerMap.set(type, handlers);\n    }\n\n    handlers.add(/** @type {import('./types').InputMessageHandler<import('./types').InputMessageType>} */ (handler));\n  }\n\n  /** @param {import('./types').OutputMessage} message */\n  send(message) {\n    this._context.postMessage(message, '*');\n  }\n\n  destroy() {\n    window.removeEventListener('message', this._handleMessage);\n  }\n}\n"],"mappings":"AAAA;;AAEA;AACA,MAAMA,sBAAsB,GAAG,CAAC,uBAAuB,EAAE,sBAAsB,CAAC;;AAEhF;AACA;AACA;AACA;AACA,MAAMC,oBAAoB,GAAIC,OAAO,IAAK;EACxC,IAAI,CAACA,OAAO,EAAE,OAAO,KAAK;EAC1B,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE,OAAO,KAAK;EAC7C,OACE,MAAM,IAAIA,OAAO,IACjBF,sBAAsB,CAACG,QAAQ,CAAC,iDAAmDD,OAAO,CAACE,IAAK,CAAC;AAErG,CAAC;AAED,OAAO,MAAMC,aAAa,CAAC;EACzB;EACAC,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAC;;EAEvB;EACAC,QAAQ;;EAER;EACAC,WAAWA,CAACC,OAAO,EAAE;IACnB,IAAI,CAACF,QAAQ,GAAGE,OAAO;IAEvBC,MAAM,CAACC,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAACC,cAAc,CAAC;EACzD;;EAEA;EACAA,cAAc,GAAIC,CAAC,IAAK;IACtB,IAAIA,CAAC,CAACC,MAAM,KAAK,IAAI,CAACP,QAAQ,EAAE;MAC9B;IACF;IACA,MAAMN,OAAO,GAAGY,CAAC,CAACE,IAAI;IACtB,IAAI,CAACf,oBAAoB,CAACC,OAAO,CAAC,EAAE;MAClC;IACF;IAEA,MAAMe,QAAQ,GAAG,IAAI,CAACX,WAAW,CAACY,GAAG,CAAChB,OAAO,CAACE,IAAI,CAAC;IACnD,IAAIa,QAAQ,EAAE;MACZ,KAAK,MAAME,OAAO,IAAIF,QAAQ,EAAE;QAC9BE,OAAO,CAACjB,OAAO,CAAC;MAClB;IACF;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;EACEkB,EAAEA,CAAChB,IAAI,EAAEe,OAAO,EAAE;IAChB,MAAMF,QAAQ,GAAG,IAAI,CAACX,WAAW,CAACY,GAAG,CAACd,IAAI,CAAC,IAAI,IAAIiB,GAAG,CAAC,CAAC;IACxD,IAAI,CAAC,IAAI,CAACf,WAAW,CAACgB,GAAG,CAAClB,IAAI,CAAC,EAAE;MAC/B,IAAI,CAACE,WAAW,CAACiB,GAAG,CAACnB,IAAI,EAAEa,QAAQ,CAAC;IACtC;IAEAA,QAAQ,CAACO,GAAG,CAAC,wFAA0FL,OAAQ,CAAC;EAClH;;EAEA;EACAM,IAAIA,CAACvB,OAAO,EAAE;IACZ,IAAI,CAACM,QAAQ,CAACkB,WAAW,CAACxB,OAAO,EAAE,GAAG,CAAC;EACzC;EAEAyB,OAAOA,CAAA,EAAG;IACRhB,MAAM,CAACiB,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAACf,cAAc,CAAC;EAC5D;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}