{"ast":null,"code":"// @ts-check\n\nimport { memoize } from '../utils/memoize.js';\nimport { warnOnce } from '../utils/warnOnce.js';\n\n/** @param {string} warning */\nfunction createAsyncAssertWrapper(warning) {\n  let isAsync = false;\n  setTimeout(() => {\n    isAsync = true;\n  }, 0);\n\n  /**\n   * @template {any[]} TArgs\n   * @template {any} TReturn\n   * @template {(...args: TArgs) => TReturn} T\n   * @param {T} fn\n   * @returns {T}\n   */\n  const withAssert = fn => {\n    return /** @type {T} */(...args) => {\n      if (isAsync) {\n        warnOnce(warning);\n      }\n      return fn(...args);\n    };\n  };\n  return withAssert;\n}\n\n/**\n * @template {import('../index.js').OutputCollectionStatus} TCollectionStatus\n * @template {import('../index.js').GroupFlag} [TGroupFlag='maybe-has-group'] Default is `'maybe-has-group'`\n * @param {import('./UploaderBlock.js').UploaderBlock} uploaderBlock\n * @returns {import('../index.js').OutputCollectionState<TCollectionStatus, TGroupFlag>}\n */\nexport function buildOutputCollectionState(uploaderBlock) {\n  const getters = {\n    /** @returns {number} */\n    progress: () => {\n      return uploaderBlock.$['*commonProgress'];\n    },\n    /** @returns {ReturnType<import('../types').OutputErrorFile>[]} */\n    errors: () => {\n      return uploaderBlock.$['*collectionErrors'];\n    },\n    /** @returns {import('@uploadcare/upload-client').UploadcareGroup | null} */\n    group: () => {\n      return uploaderBlock.$['*groupInfo'];\n    },\n    totalCount: () => {\n      return uploaderBlock.uploadCollection.size;\n    },\n    failedCount: () => {\n      return state.failedEntries.length;\n    },\n    successCount: () => {\n      return state.successEntries.length;\n    },\n    uploadingCount: () => {\n      return state.uploadingEntries.length;\n    },\n    status: () => {\n      const status = state.isFailed ? 'failed' : state.isUploading ? 'uploading' : state.isSuccess ? 'success' : 'idle';\n      return /** @type {TCollectionStatus} */status;\n    },\n    isSuccess: () => {\n      return state.allEntries.length > 0 && state.errors.length === 0 && state.successEntries.length === state.allEntries.length;\n    },\n    isUploading: () => {\n      return state.allEntries.some(entry => entry.status === 'uploading');\n    },\n    isFailed: () => {\n      return state.errors.length > 0 || state.failedEntries.length > 0;\n    },\n    allEntries: () => {\n      return uploaderBlock.getOutputData();\n    },\n    successEntries: () => {\n      return state.allEntries.filter(entry => entry.status === 'success');\n    },\n    failedEntries: () => {\n      return state.allEntries.filter(entry => entry.status === 'failed');\n    },\n    uploadingEntries: () => {\n      return state.allEntries.filter(entry => entry.status === 'uploading');\n    },\n    idleEntries: () => {\n      return state.allEntries.filter(entry => entry.status === 'idle');\n    }\n  };\n  const state = /** @type {import('../index.js').OutputCollectionState<TCollectionStatus, TGroupFlag>} */\n  /** @type {unknown} */{};\n  const withAssert = createAsyncAssertWrapper(\"You're trying to access the OutputCollectionState asynchronously. \" + 'In this case, the data you retrieve will be newer than it was when the ' + 'OutputCollectionState was created or when the event was dispatched. If you want ' + 'to retain the state at a specific moment in time, you should use the spread operator ' + 'like this: `{...outputCollectionState}` or `{...e.detail}`');\n  for (const [key, value] of Object.entries(getters)) {\n    const name = /** @type {keyof typeof getters} */key;\n    const getter = /** @type {(typeof getters)[name]} */value;\n    const wrapped = memoize(withAssert(getter));\n    Object.defineProperty(state, name, {\n      get: wrapped,\n      enumerable: true\n    });\n  }\n  return state;\n}","map":{"version":3,"names":["memoize","warnOnce","createAsyncAssertWrapper","warning","isAsync","setTimeout","withAssert","fn","args","buildOutputCollectionState","uploaderBlock","getters","progress","$","errors","group","totalCount","uploadCollection","size","failedCount","state","failedEntries","length","successCount","successEntries","uploadingCount","uploadingEntries","status","isFailed","isUploading","isSuccess","allEntries","some","entry","getOutputData","filter","idleEntries","key","value","Object","entries","name","getter","wrapped","defineProperty","get","enumerable"],"sources":["/Users/kavinth/Documents/GitHub/Smart-Alert/Smart-Alert-new/frontend/node_modules/@uploadcare/file-uploader/abstract/buildOutputCollectionState.js"],"sourcesContent":["// @ts-check\n\nimport { memoize } from '../utils/memoize.js';\nimport { warnOnce } from '../utils/warnOnce.js';\n\n/** @param {string} warning */\nfunction createAsyncAssertWrapper(warning) {\n  let isAsync = false;\n  setTimeout(() => {\n    isAsync = true;\n  }, 0);\n\n  /**\n   * @template {any[]} TArgs\n   * @template {any} TReturn\n   * @template {(...args: TArgs) => TReturn} T\n   * @param {T} fn\n   * @returns {T}\n   */\n  const withAssert = (fn) => {\n    return /** @type {T} */ (\n      (...args) => {\n        if (isAsync) {\n          warnOnce(warning);\n        }\n        return fn(...args);\n      }\n    );\n  };\n\n  return withAssert;\n}\n\n/**\n * @template {import('../index.js').OutputCollectionStatus} TCollectionStatus\n * @template {import('../index.js').GroupFlag} [TGroupFlag='maybe-has-group'] Default is `'maybe-has-group'`\n * @param {import('./UploaderBlock.js').UploaderBlock} uploaderBlock\n * @returns {import('../index.js').OutputCollectionState<TCollectionStatus, TGroupFlag>}\n */\nexport function buildOutputCollectionState(uploaderBlock) {\n  const getters = {\n    /** @returns {number} */\n    progress: () => {\n      return uploaderBlock.$['*commonProgress'];\n    },\n    /** @returns {ReturnType<import('../types').OutputErrorFile>[]} */\n    errors: () => {\n      return uploaderBlock.$['*collectionErrors'];\n    },\n\n    /** @returns {import('@uploadcare/upload-client').UploadcareGroup | null} */\n    group: () => {\n      return uploaderBlock.$['*groupInfo'];\n    },\n\n    totalCount: () => {\n      return uploaderBlock.uploadCollection.size;\n    },\n\n    failedCount: () => {\n      return state.failedEntries.length;\n    },\n\n    successCount: () => {\n      return state.successEntries.length;\n    },\n\n    uploadingCount: () => {\n      return state.uploadingEntries.length;\n    },\n\n    status: () => {\n      const status = state.isFailed ? 'failed' : state.isUploading ? 'uploading' : state.isSuccess ? 'success' : 'idle';\n      return /** @type {TCollectionStatus} */ (status);\n    },\n\n    isSuccess: () => {\n      return (\n        state.allEntries.length > 0 &&\n        state.errors.length === 0 &&\n        state.successEntries.length === state.allEntries.length\n      );\n    },\n\n    isUploading: () => {\n      return state.allEntries.some((entry) => entry.status === 'uploading');\n    },\n\n    isFailed: () => {\n      return state.errors.length > 0 || state.failedEntries.length > 0;\n    },\n\n    allEntries: () => {\n      return uploaderBlock.getOutputData();\n    },\n\n    successEntries: () => {\n      return state.allEntries.filter((entry) => entry.status === 'success');\n    },\n\n    failedEntries: () => {\n      return state.allEntries.filter((entry) => entry.status === 'failed');\n    },\n\n    uploadingEntries: () => {\n      return state.allEntries.filter((entry) => entry.status === 'uploading');\n    },\n\n    idleEntries: () => {\n      return state.allEntries.filter((entry) => entry.status === 'idle');\n    },\n  };\n\n  const state = /** @type {import('../index.js').OutputCollectionState<TCollectionStatus, TGroupFlag>} */ (\n    /** @type {unknown} */ ({})\n  );\n  const withAssert = createAsyncAssertWrapper(\n    \"You're trying to access the OutputCollectionState asynchronously. \" +\n      'In this case, the data you retrieve will be newer than it was when the ' +\n      'OutputCollectionState was created or when the event was dispatched. If you want ' +\n      'to retain the state at a specific moment in time, you should use the spread operator ' +\n      'like this: `{...outputCollectionState}` or `{...e.detail}`',\n  );\n\n  for (const [key, value] of Object.entries(getters)) {\n    const name = /** @type {keyof typeof getters} */ (key);\n    const getter = /** @type {(typeof getters)[name]} */ (value);\n    const wrapped = memoize(withAssert(getter));\n    Object.defineProperty(state, name, {\n      get: wrapped,\n      enumerable: true,\n    });\n  }\n\n  return state;\n}\n"],"mappings":"AAAA;;AAEA,SAASA,OAAO,QAAQ,qBAAqB;AAC7C,SAASC,QAAQ,QAAQ,sBAAsB;;AAE/C;AACA,SAASC,wBAAwBA,CAACC,OAAO,EAAE;EACzC,IAAIC,OAAO,GAAG,KAAK;EACnBC,UAAU,CAAC,MAAM;IACfD,OAAO,GAAG,IAAI;EAChB,CAAC,EAAE,CAAC,CAAC;;EAEL;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAME,UAAU,GAAIC,EAAE,IAAK;IACzB,OAAO,gBACL,CAAC,GAAGC,IAAI,KAAK;MACX,IAAIJ,OAAO,EAAE;QACXH,QAAQ,CAACE,OAAO,CAAC;MACnB;MACA,OAAOI,EAAE,CAAC,GAAGC,IAAI,CAAC;IACpB,CAAC;EAEL,CAAC;EAED,OAAOF,UAAU;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,0BAA0BA,CAACC,aAAa,EAAE;EACxD,MAAMC,OAAO,GAAG;IACd;IACAC,QAAQ,EAAEA,CAAA,KAAM;MACd,OAAOF,aAAa,CAACG,CAAC,CAAC,iBAAiB,CAAC;IAC3C,CAAC;IACD;IACAC,MAAM,EAAEA,CAAA,KAAM;MACZ,OAAOJ,aAAa,CAACG,CAAC,CAAC,mBAAmB,CAAC;IAC7C,CAAC;IAED;IACAE,KAAK,EAAEA,CAAA,KAAM;MACX,OAAOL,aAAa,CAACG,CAAC,CAAC,YAAY,CAAC;IACtC,CAAC;IAEDG,UAAU,EAAEA,CAAA,KAAM;MAChB,OAAON,aAAa,CAACO,gBAAgB,CAACC,IAAI;IAC5C,CAAC;IAEDC,WAAW,EAAEA,CAAA,KAAM;MACjB,OAAOC,KAAK,CAACC,aAAa,CAACC,MAAM;IACnC,CAAC;IAEDC,YAAY,EAAEA,CAAA,KAAM;MAClB,OAAOH,KAAK,CAACI,cAAc,CAACF,MAAM;IACpC,CAAC;IAEDG,cAAc,EAAEA,CAAA,KAAM;MACpB,OAAOL,KAAK,CAACM,gBAAgB,CAACJ,MAAM;IACtC,CAAC;IAEDK,MAAM,EAAEA,CAAA,KAAM;MACZ,MAAMA,MAAM,GAAGP,KAAK,CAACQ,QAAQ,GAAG,QAAQ,GAAGR,KAAK,CAACS,WAAW,GAAG,WAAW,GAAGT,KAAK,CAACU,SAAS,GAAG,SAAS,GAAG,MAAM;MACjH,OAAO,gCAAkCH,MAAM;IACjD,CAAC;IAEDG,SAAS,EAAEA,CAAA,KAAM;MACf,OACEV,KAAK,CAACW,UAAU,CAACT,MAAM,GAAG,CAAC,IAC3BF,KAAK,CAACN,MAAM,CAACQ,MAAM,KAAK,CAAC,IACzBF,KAAK,CAACI,cAAc,CAACF,MAAM,KAAKF,KAAK,CAACW,UAAU,CAACT,MAAM;IAE3D,CAAC;IAEDO,WAAW,EAAEA,CAAA,KAAM;MACjB,OAAOT,KAAK,CAACW,UAAU,CAACC,IAAI,CAAEC,KAAK,IAAKA,KAAK,CAACN,MAAM,KAAK,WAAW,CAAC;IACvE,CAAC;IAEDC,QAAQ,EAAEA,CAAA,KAAM;MACd,OAAOR,KAAK,CAACN,MAAM,CAACQ,MAAM,GAAG,CAAC,IAAIF,KAAK,CAACC,aAAa,CAACC,MAAM,GAAG,CAAC;IAClE,CAAC;IAEDS,UAAU,EAAEA,CAAA,KAAM;MAChB,OAAOrB,aAAa,CAACwB,aAAa,CAAC,CAAC;IACtC,CAAC;IAEDV,cAAc,EAAEA,CAAA,KAAM;MACpB,OAAOJ,KAAK,CAACW,UAAU,CAACI,MAAM,CAAEF,KAAK,IAAKA,KAAK,CAACN,MAAM,KAAK,SAAS,CAAC;IACvE,CAAC;IAEDN,aAAa,EAAEA,CAAA,KAAM;MACnB,OAAOD,KAAK,CAACW,UAAU,CAACI,MAAM,CAAEF,KAAK,IAAKA,KAAK,CAACN,MAAM,KAAK,QAAQ,CAAC;IACtE,CAAC;IAEDD,gBAAgB,EAAEA,CAAA,KAAM;MACtB,OAAON,KAAK,CAACW,UAAU,CAACI,MAAM,CAAEF,KAAK,IAAKA,KAAK,CAACN,MAAM,KAAK,WAAW,CAAC;IACzE,CAAC;IAEDS,WAAW,EAAEA,CAAA,KAAM;MACjB,OAAOhB,KAAK,CAACW,UAAU,CAACI,MAAM,CAAEF,KAAK,IAAKA,KAAK,CAACN,MAAM,KAAK,MAAM,CAAC;IACpE;EACF,CAAC;EAED,MAAMP,KAAK,GAAG;EACZ,sBAAwB,CAAC,CAC1B;EACD,MAAMd,UAAU,GAAGJ,wBAAwB,CACzC,oEAAoE,GAClE,yEAAyE,GACzE,kFAAkF,GAClF,uFAAuF,GACvF,4DACJ,CAAC;EAED,KAAK,MAAM,CAACmC,GAAG,EAAEC,KAAK,CAAC,IAAIC,MAAM,CAACC,OAAO,CAAC7B,OAAO,CAAC,EAAE;IAClD,MAAM8B,IAAI,GAAG,mCAAqCJ,GAAI;IACtD,MAAMK,MAAM,GAAG,qCAAuCJ,KAAM;IAC5D,MAAMK,OAAO,GAAG3C,OAAO,CAACM,UAAU,CAACoC,MAAM,CAAC,CAAC;IAC3CH,MAAM,CAACK,cAAc,CAACxB,KAAK,EAAEqB,IAAI,EAAE;MACjCI,GAAG,EAAEF,OAAO;MACZG,UAAU,EAAE;IACd,CAAC,CAAC;EACJ;EAEA,OAAO1B,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}