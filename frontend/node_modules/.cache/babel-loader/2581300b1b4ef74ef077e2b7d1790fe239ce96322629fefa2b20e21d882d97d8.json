{"ast":null,"code":"// TODO: unwrap promises\nconst readJpegChunks = () => {\n  const stack = [];\n  const promiseReadJpegChunks = blob => new Promise((resolve, reject) => {\n    let pos = 2;\n    const readToView = (blob, cb) => {\n      const reader = new FileReader();\n      reader.addEventListener('load', () => {\n        cb(new DataView(reader.result));\n      });\n      reader.addEventListener('error', e => {\n        reject(`Reader error: ${e}`);\n      });\n      reader.readAsArrayBuffer(blob);\n    };\n    const readNext = () => readToView(blob.slice(pos, pos + 128), view => {\n      let i, j, ref;\n      for (i = j = 0, ref = view.byteLength; ref >= 0 ? j < ref : j > ref; i = ref >= 0 ? ++j : --j) {\n        if (view.getUint8(i) === 0xff) {\n          pos += i;\n          break;\n        }\n      }\n      readNextChunk();\n    });\n    const readNextChunk = () => {\n      const startPos = pos;\n      return readToView(blob.slice(pos, pos += 4), view => {\n        if (view.byteLength !== 4 || view.getUint8(0) !== 0xff) {\n          reject('Corrupted');\n          return;\n        }\n        const marker = view.getUint8(1);\n        if (marker === 0xda) {\n          resolve(true);\n          return;\n        }\n        const length = view.getUint16(2) - 2;\n        return readToView(blob.slice(pos, pos += length), view => {\n          if (view.byteLength !== length) {\n            reject('Corrupted');\n            return;\n          }\n          stack.push({\n            startPos,\n            length,\n            marker,\n            view\n          });\n          readNext();\n        });\n      });\n    };\n    if (!(FileReader && DataView)) {\n      reject('Not Support');\n    }\n    readToView(blob.slice(0, 2), view => {\n      if (view.getUint16(0) !== 0xffd8) {\n        reject('Not jpeg');\n      }\n      readNext();\n    });\n  });\n  return {\n    stack,\n    promiseReadJpegChunks\n  };\n};\nconst getIccProfile = async blob => {\n  const iccProfile = [];\n  const {\n    promiseReadJpegChunks,\n    stack\n  } = readJpegChunks();\n  await promiseReadJpegChunks(blob);\n  stack.forEach(({\n    marker,\n    view\n  }) => {\n    if (marker === 0xe2) {\n      if (\n      // check for \"ICC_PROFILE\\0\"\n      view.getUint32(0) === 0x4943435f && view.getUint32(4) === 0x50524f46 && view.getUint32(8) === 0x494c4500) {\n        iccProfile.push(view);\n      }\n    }\n  });\n  return iccProfile;\n};\nconst replaceJpegChunk = async (blob, marker, chunks) => {\n  {\n    const oldChunkPos = [];\n    const oldChunkLength = [];\n    const {\n      promiseReadJpegChunks,\n      stack\n    } = readJpegChunks();\n    await promiseReadJpegChunks(blob);\n    stack.forEach(chunk => {\n      if (chunk.marker === marker) {\n        oldChunkPos.push(chunk.startPos);\n        return oldChunkLength.push(chunk.length);\n      }\n    });\n    const newChunks = [blob.slice(0, 2)];\n    for (const chunk of chunks) {\n      const intro = new DataView(new ArrayBuffer(4));\n      intro.setUint16(0, 0xff00 + marker);\n      intro.setUint16(2, chunk.byteLength + 2);\n      newChunks.push(intro.buffer);\n      newChunks.push(chunk);\n    }\n    let pos = 2;\n    for (let i = 0; i < oldChunkPos.length; i++) {\n      if (oldChunkPos[i] > pos) {\n        newChunks.push(blob.slice(pos, oldChunkPos[i]));\n      }\n      pos = oldChunkPos[i] + oldChunkLength[i] + 4;\n    }\n    newChunks.push(blob.slice(pos, blob.size));\n    return new Blob(newChunks, {\n      type: blob.type\n    });\n  }\n};\nconst MARKER = 0xe2;\nconst replaceIccProfile = (blob, iccProfiles) => {\n  return replaceJpegChunk(blob, MARKER, iccProfiles.map(chunk => chunk.buffer));\n};\nconst stripIccProfile = async blob => {\n  try {\n    return await replaceIccProfile(blob, []);\n  } catch (e) {\n    throw new Error(`Failed to strip ICC profile: ${e}`);\n  }\n};\nconst canvasToBlob = (canvas, type, quality) => {\n  return new Promise((resolve, reject) => {\n    const callback = blob => {\n      if (!blob) {\n        reject('Failed to convert canvas to blob');\n        return;\n      }\n      resolve(blob);\n    };\n    canvas.toBlob(callback, type, quality);\n    canvas.width = canvas.height = 1;\n  });\n};\nconst createCanvas = () => {\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  return {\n    canvas,\n    ctx\n  };\n};\nconst hasTransparency = img => {\n  const canvasSize = 50;\n  // Create a canvas element and get 2D rendering context\n  const {\n    ctx,\n    canvas\n  } = createCanvas();\n  canvas.width = canvas.height = canvasSize;\n  // Draw the image onto the canvas\n  ctx.drawImage(img, 0, 0, canvasSize, canvasSize);\n  // Get the image data\n  const imageData = ctx.getImageData(0, 0, canvasSize, canvasSize).data;\n  // Reset the canvas dimensions\n  canvas.width = canvas.height = 1;\n  // Check for transparency in the alpha channel\n  for (let i = 3; i < imageData.length; i += 4) {\n    if (imageData[i] < 254) {\n      return true;\n    }\n  }\n  // No transparency found\n  return false;\n};\nconst getExif = async blob => {\n  let exif = null;\n  const {\n    promiseReadJpegChunks,\n    stack\n  } = readJpegChunks();\n  await promiseReadJpegChunks(blob);\n  stack.forEach(({\n    marker,\n    view\n  }) => {\n    if (!exif && marker === 0xe1) {\n      if (view.byteLength >= 14) {\n        if (\n        // check for \"Exif\\0\"\n        view.getUint32(0) === 0x45786966 && view.getUint16(4) === 0) {\n          exif = view;\n          return;\n        }\n      }\n    }\n  });\n  return exif;\n};\n\n// 2x1 pixel image 90CW rotated with orientation header\nconst base64ImageSrc = 'data:image/jpg;base64,' + '/9j/4AAQSkZJRgABAQEASABIAAD/4QA6RXhpZgAATU0AKgAAAAgAAwESAAMAAAABAAYAAAEo' + 'AAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAD/2wBDAP//////////////////////////////' + '////////////////////////////////////////////////////////wAALCAABAAIBASIA' + '/8QAJgABAAAAAAAAAAAAAAAAAAAAAxABAAAAAAAAAAAAAAAAAAAAAP/aAAgBAQAAPwBH/9k=';\nlet isApplied = undefined;\nconst isBrowserApplyExifOrientation = () => {\n  return new Promise(resolve => {\n    if (isApplied !== undefined) {\n      resolve(isApplied);\n    } else {\n      const image = new Image();\n      image.addEventListener('load', () => {\n        isApplied = image.naturalWidth < image.naturalHeight;\n        image.src = '//:0';\n        resolve(isApplied);\n      });\n      image.src = base64ImageSrc;\n    }\n  });\n};\nconst findExifOrientation = (exif, exifCallback) => {\n  let j, little, offset, ref;\n  if (!exif || exif.byteLength < 14 || exif.getUint32(0) !== 0x45786966 || exif.getUint16(4) !== 0) {\n    return;\n  }\n  if (exif.getUint16(6) === 0x4949) {\n    little = true;\n  } else if (exif.getUint16(6) === 0x4d4d) {\n    little = false;\n  } else {\n    return;\n  }\n  if (exif.getUint16(8, little) !== 0x002a) {\n    return;\n  }\n  offset = 8 + exif.getUint32(10, little);\n  const count = exif.getUint16(offset - 2, little);\n  for (j = 0, ref = count; ref >= 0 ? j < ref : j > ref; ref >= 0 ? ++j : --j) {\n    if (exif.byteLength < offset + 10) {\n      return;\n    }\n    if (exif.getUint16(offset, little) === 0x0112) {\n      exifCallback(offset + 8, little);\n    }\n    offset += 12;\n  }\n};\nconst setExifOrientation = (exif, orientation) => {\n  findExifOrientation(exif, (offset, littleEndian) => exif.setUint16(offset, orientation, littleEndian));\n};\nconst replaceExif = async (blob, exif, isExifApplied) => {\n  if (isExifApplied) {\n    setExifOrientation(exif, 1);\n  }\n  return replaceJpegChunk(blob, 0xe1, [exif.buffer]);\n};\nconst processImage = (image, src) => {\n  return new Promise((resolve, reject) => {\n    if (src) {\n      image.src = src;\n    }\n    if (image.complete) {\n      resolve(image);\n    } else {\n      image.addEventListener('load', () => {\n        resolve(image);\n      });\n      image.addEventListener('error', () => {\n        reject(new Error('Failed to load image. Probably not an image.'));\n      });\n    }\n  });\n};\nconst imageLoader = image => {\n  return processImage(new Image(), image);\n};\nconst allowLayers = [1,\n// L (black-white)\n3 // RGB\n];\nconst markers = [0xc0,\n// (\"SOF0\", \"Baseline DCT\", SOF)\n0xc1,\n// (\"SOF1\", \"Extended Sequential DCT\", SOF)\n0xc2,\n// (\"SOF2\", \"Progressive DCT\", SOF)\n0xc3,\n// (\"SOF3\", \"Spatial lossless\", SOF)\n0xc5,\n// (\"SOF5\", \"Differential sequential DCT\", SOF)\n0xc6,\n// (\"SOF6\", \"Differential progressive DCT\", SOF)\n0xc7,\n// (\"SOF7\", \"Differential spatial\", SOF)\n0xc9,\n// (\"SOF9\", \"Extended sequential DCT (AC)\", SOF)\n0xca,\n// (\"SOF10\", \"Progressive DCT (AC)\", SOF)\n0xcb,\n// (\"SOF11\", \"Spatial lossless DCT (AC)\", SOF)\n0xcd,\n// (\"SOF13\", \"Differential sequential DCT (AC)\", SOF)\n0xce,\n// (\"SOF14\", \"Differential progressive DCT (AC)\", SOF)\n0xcf // (\"SOF15\", \"Differential spatial (AC)\", SOF)\n];\nconst sizes = {\n  squareSide: [\n  // Safari (iOS < 9, ram >= 256)\n  // We are supported mobile safari < 9 since widget v2, by 5 Mpx limit\n  // so it's better to continue support despite the absence of this browser in the support table\n  Math.floor(Math.sqrt(5 * 1000 * 1000)),\n  // IE Mobile (Windows Phone 8.x)\n  // Safari (iOS >= 9)\n  4096,\n  // IE 9 (Win)\n  8192,\n  // Firefox 63 (Mac, Win)\n  11180,\n  // Chrome 68 (Android 6)\n  10836,\n  // Chrome 68 (Android 5)\n  11402,\n  // Chrome 68 (Android 7.1-9)\n  14188,\n  // Chrome 70 (Mac, Win)\n  // Chrome 68 (Android 4.4)\n  // Edge 17 (Win)\n  // Safari 7-12 (Mac)\n  16384],\n  dimension: [\n  // IE Mobile (Windows Phone 8.x)\n  4096,\n  // IE 9 (Win)\n  8192,\n  // Edge 17 (Win)\n  // IE11 (Win)\n  16384,\n  // Chrome 70 (Mac, Win)\n  // Chrome 68 (Android 4.4-9)\n  // Firefox 63 (Mac, Win)\n  32767,\n  // Chrome 83 (Mac, Win)\n  // Safari 7-12 (Mac)\n  // Safari (iOS 9-12)\n  // Actually Safari has a much bigger limits - 4194303 of width and 8388607 of height,\n  // but we will not use them\n  65535]\n};\nconst shouldSkipShrink = async blob => {\n  let skip = false;\n  const {\n    promiseReadJpegChunks,\n    stack\n  } = readJpegChunks();\n  return await promiseReadJpegChunks(blob).then(() => {\n    stack.forEach(({\n      marker,\n      view\n    }) => {\n      if (!skip && markers.indexOf(marker) >= 0) {\n        const layer = view.getUint8(5);\n        if (allowLayers.indexOf(layer) < 0) {\n          skip = true;\n        }\n      }\n    });\n    return skip;\n  }).catch(() => skip);\n};\nconst memoize = (fn, serializer) => {\n  const cache = {};\n  return (...args) => {\n    const key = serializer(args, cache);\n    return key in cache ? cache[key] : cache[key] = fn(...args);\n  };\n};\n/**\n * Memoization key serealizer, that prevents unnecessary canvas tests. No need\n * to make test if we know that:\n *\n * - Browser supports higher canvas size\n * - Browser doesn't support lower canvas size\n */\nconst memoKeySerializer = (args, cache) => {\n  const [w] = args;\n  const cachedWidths = Object.keys(cache).map(val => parseInt(val, 10)).sort((a, b) => a - b);\n  for (let i = 0; i < cachedWidths.length; i++) {\n    const cachedWidth = cachedWidths[i];\n    const isSupported = !!cache[cachedWidth];\n    // higher supported canvas size, return it\n    if (cachedWidth > w && isSupported) {\n      return cachedWidth;\n    }\n    // lower unsupported canvas size, return it\n    if (cachedWidth < w && !isSupported) {\n      return cachedWidth;\n    }\n  }\n  // use canvas width as the key,\n  // because we're doing dimension test by width - [dimension, 1]\n  return w;\n};\n\n// add constants\nconst TestPixel = {\n  R: 55,\n  G: 110,\n  B: 165,\n  A: 255\n};\nconst FILL_STYLE = `rgba(${TestPixel.R}, ${TestPixel.G}, ${TestPixel.B}, ${TestPixel.A / 255})`;\nconst canvasTest = (width, height) => {\n  try {\n    const fill = [width - 1, height - 1, 1, 1]; // x, y, width, height\n    const {\n      canvas: cropCvs,\n      ctx: cropCtx\n    } = createCanvas();\n    cropCvs.width = 1;\n    cropCvs.height = 1;\n    const {\n      canvas: testCvs,\n      ctx: testCtx\n    } = createCanvas();\n    testCvs.width = width;\n    testCvs.height = height;\n    if (testCtx) {\n      testCtx.fillStyle = FILL_STYLE;\n      testCtx.fillRect(...fill);\n      // Render the test pixel in the bottom-right corner of the\n      // test canvas in the top-left of the 1x1 crop canvas. This\n      // dramatically reducing the time for getImageData to complete.\n      cropCtx.drawImage(testCvs, width - 1, height - 1, 1, 1, 0, 0, 1, 1);\n    }\n    const imageData = cropCtx && cropCtx.getImageData(0, 0, 1, 1).data;\n    let isTestPass = false;\n    if (imageData) {\n      // On IE10, imageData have type CanvasPixelArray, not Uint8ClampedArray.\n      // CanvasPixelArray supports index access operations only.\n      // Array buffers can't be destructuredd and compared with JSON.stringify\n      isTestPass = imageData[0] === TestPixel.R && imageData[1] === TestPixel.G && imageData[2] === TestPixel.B && imageData[3] === TestPixel.A;\n    }\n    testCvs.width = testCvs.height = 1;\n    return isTestPass;\n  } catch (e) {\n    console.error(`Failed to test for max canvas size of ${width}x${height}.`);\n    return false;\n  }\n};\nfunction wrapAsync(fn) {\n  return (...args) => {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        const result = fn(...args);\n        resolve(result);\n      }, 0);\n    });\n  };\n}\nconst squareTest = wrapAsync(memoize(canvasTest, memoKeySerializer));\nconst dimensionTest = wrapAsync(memoize(canvasTest, memoKeySerializer));\nconst testCanvasSize = async (w, h) => {\n  const testSquareSide = sizes.squareSide.find(side => side * side >= w * h);\n  const testDimension = sizes.dimension.find(side => side >= w && side >= h);\n  if (!testSquareSide || !testDimension) {\n    throw new Error('Not supported');\n  }\n  const [squareSupported, dimensionSupported] = await Promise.all([squareTest(testSquareSide, testSquareSide), dimensionTest(testDimension, 1)]);\n  if (squareSupported && dimensionSupported) {\n    return true;\n  } else {\n    throw new Error('Not supported');\n  }\n};\nconst canvasResize = async (img, w, h) => {\n  try {\n    const {\n      ctx,\n      canvas\n    } = createCanvas();\n    canvas.width = w;\n    canvas.height = h;\n    ctx.imageSmoothingQuality = 'high';\n    ctx.drawImage(img, 0, 0, w, h);\n    if (img instanceof HTMLImageElement) {\n      img.src = '//:0'; // free memory\n    }\n    if (img instanceof HTMLCanvasElement) {\n      img.width = img.height = 1; // free memory\n    }\n    return canvas;\n  } catch (e) {\n    throw new Error('Canvas resize error', {\n      cause: e\n    });\n  }\n};\n\n/**\n * Native high-quality canvas resampling\n *\n * Browser support:\n * https://caniuse.com/mdn-api_canvasrenderingcontext2d_imagesmoothingenabled\n * Target dimensions expected to be supported by browser.\n */\nconst native = ({\n  img,\n  targetW,\n  targetH\n}) => canvasResize(img, targetW, targetH);\n\n/**\n * Goes from target to source by step, the last incomplete step is dropped.\n * Always returns at least one step - target. Source step is not included.\n * Sorted descending.\n *\n * Example with step = 0.71, source = 2000, target = 400 400 (target) <- 563 <-\n * 793 <- 1117 <- 1574 (dropped) <- [2000 (source)]\n */\nconst calcShrinkSteps = function ({\n  sourceW,\n  targetW,\n  targetH,\n  step\n}) {\n  const steps = [];\n  let sW = targetW;\n  let sH = targetH;\n  // result should include at least one target step,\n  // even if abs(source - target) < step * source\n  // just to be sure nothing will break\n  // if the original resolution / target resolution condition changes\n  do {\n    steps.push([sW, sH]);\n    sW = Math.round(sW / step);\n    sH = Math.round(sH / step);\n  } while (sW < sourceW * step);\n  return steps.reverse();\n};\n/**\n * Fallback resampling algorithm\n *\n * Reduces dimensions by step until reaches target dimensions, this gives a\n * better output quality than one-step method\n *\n * Target dimensions expected to be supported by browser, unsupported steps will\n * be dropped.\n */\nconst fallback = ({\n  img,\n  sourceW,\n  targetW,\n  targetH,\n  step\n}) => {\n  const steps = calcShrinkSteps({\n    sourceW,\n    targetW,\n    targetH,\n    step\n  });\n  return steps.reduce((chain, [w, h], idx) => {\n    return chain.then(canvas => {\n      return testCanvasSize(w, h).then(() => canvasResize(canvas, w, h)).catch(() => {\n        if (idx === steps.length - 1) {\n          // If the last step is failed then we assume that we can't shrink the image at all\n          throw new Error('Not supported');\n        }\n        return canvas;\n      });\n    });\n  }, Promise.resolve(img));\n};\nconst isIOS = () => {\n  if (/iPad|iPhone|iPod/.test(navigator.platform)) {\n    return true;\n  } else {\n    return navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform);\n  }\n};\nconst isIpadOS = navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform);\nconst STEP = 0.71; // should be > sqrt(0.5)\nconst shrinkImage = (img, settings) => {\n  // do not shrink image if original resolution / target resolution ratio falls behind 2.0\n  if (img.width * STEP * img.height * STEP < settings.size) {\n    throw new Error('Not required');\n  }\n  const sourceW = img.width;\n  const sourceH = img.height;\n  const ratio = sourceW / sourceH;\n  // target size shouldn't be greater than settings.size in any case\n  const targetW = Math.floor(Math.sqrt(settings.size * ratio));\n  const targetH = Math.floor(settings.size / Math.sqrt(settings.size * ratio));\n  // we test the last step because we can skip all intermediate steps\n  return testCanvasSize(targetW, targetH).then(() => {\n    const {\n      ctx\n    } = createCanvas();\n    const supportNative = 'imageSmoothingQuality' in ctx;\n    // native scaling on ios gives blurry results\n    // TODO: check if it's still true\n    const useNativeScaling = supportNative && !isIOS() && !isIpadOS;\n    return useNativeScaling ? native({\n      img,\n      targetW,\n      targetH\n    }) : fallback({\n      img,\n      sourceW,\n      targetW,\n      targetH,\n      step: STEP\n    });\n  }).catch(() => Promise.reject('Not supported'));\n};\nconst shrinkFile = async (inputBlob, settings) => {\n  try {\n    const shouldSkip = await shouldSkipShrink(inputBlob);\n    if (shouldSkip) {\n      throw new Error('Should skipped');\n    }\n    // Try to extract EXIF and ICC profile\n    const exifResults = await Promise.allSettled([getExif(inputBlob), isBrowserApplyExifOrientation(), getIccProfile(inputBlob)]);\n    const isRejected = exifResults.some(result => result.status === 'rejected');\n    // If any of the promises is rejected, this is not a JPEG image\n    const isJPEG = !isRejected;\n    const [exifResult, isExifOrientationAppliedResult, iccProfileResult] = exifResults;\n    // Load blob into the image\n    const inputBlobWithoutIcc = await stripIccProfile(inputBlob).catch(() => inputBlob);\n    const image = await imageLoader(URL.createObjectURL(inputBlobWithoutIcc));\n    URL.revokeObjectURL(image.src);\n    // Shrink the image\n    const canvas = await shrinkImage(image, settings);\n    let format = 'image/jpeg';\n    let quality = settings?.quality || 0.8;\n    if (!isJPEG && hasTransparency(canvas)) {\n      format = 'image/png';\n      quality = undefined;\n    }\n    // Convert canvas to blob\n    let newBlob = await canvasToBlob(canvas, format, quality);\n    // Set EXIF for the new blob\n    if (isJPEG && exifResult.status === 'fulfilled' && exifResult.value) {\n      const exif = exifResult.value;\n      const isExifOrientationApplied = isExifOrientationAppliedResult.status === 'fulfilled' ? isExifOrientationAppliedResult.value : false;\n      newBlob = await replaceExif(newBlob, exif, isExifOrientationApplied);\n      // TODO: should we continue shrink if failed to replace EXIF?\n      // .catch(() => newBlob)\n    }\n    // Set ICC profile for the new blob\n    if (isJPEG && iccProfileResult.status === 'fulfilled' && iccProfileResult.value.length > 0) {\n      newBlob = await replaceIccProfile(newBlob, iccProfileResult.value);\n      // TODO: should we continue shrink if failed to replace ICC?\n      // .catch(() => newBlob)\n    }\n    return newBlob;\n  } catch (e) {\n    let message;\n    if (e instanceof Error) {\n      message = e.message;\n    }\n    if (typeof e === 'string') {\n      message = e;\n    }\n    throw new Error(`Failed to shrink image. ${message ? `Message: \"${message}\".` : ''}`, {\n      cause: e\n    });\n  }\n};\nexport { shrinkFile };","map":{"version":3,"names":["readJpegChunks","stack","promiseReadJpegChunks","blob","Promise","resolve","reject","pos","readToView","cb","reader","FileReader","addEventListener","DataView","result","e","readAsArrayBuffer","readNext","slice","view","i","j","ref","byteLength","getUint8","readNextChunk","startPos","marker","length","getUint16","push","getIccProfile","iccProfile","forEach","getUint32","replaceJpegChunk","chunks","oldChunkPos","oldChunkLength","chunk","newChunks","intro","ArrayBuffer","setUint16","buffer","size","Blob","type","MARKER","replaceIccProfile","iccProfiles","map","stripIccProfile","Error","canvasToBlob","canvas","quality","callback","toBlob","width","height","createCanvas","document","createElement","ctx","getContext","hasTransparency","img","canvasSize","drawImage","imageData","getImageData","data","getExif","exif","base64ImageSrc","isApplied","undefined","isBrowserApplyExifOrientation","image","Image","naturalWidth","naturalHeight","src","findExifOrientation","exifCallback","little","offset","count","setExifOrientation","orientation","littleEndian","replaceExif","isExifApplied","processImage","complete","imageLoader","allowLayers","markers","sizes","squareSide","Math","floor","sqrt","dimension","shouldSkipShrink","skip","then","indexOf","layer","catch","memoize","fn","serializer","cache","args","key","memoKeySerializer","w","cachedWidths","Object","keys","val","parseInt","sort","a","b","cachedWidth","isSupported","TestPixel","R","G","B","A","FILL_STYLE","canvasTest","fill","cropCvs","cropCtx","testCvs","testCtx","fillStyle","fillRect","isTestPass","console","error","wrapAsync","setTimeout","squareTest","dimensionTest","testCanvasSize","h","testSquareSide","find","side","testDimension","squareSupported","dimensionSupported","all","canvasResize","imageSmoothingQuality","HTMLImageElement","HTMLCanvasElement","cause","native","targetW","targetH","calcShrinkSteps","sourceW","step","steps","sW","sH","round","reverse","fallback","reduce","chain","idx","isIOS","test","navigator","platform","maxTouchPoints","isIpadOS","STEP","shrinkImage","settings","sourceH","ratio","supportNative","useNativeScaling","shrinkFile","inputBlob","shouldSkip","exifResults","allSettled","isRejected","some","status","isJPEG","exifResult","isExifOrientationAppliedResult","iccProfileResult","inputBlobWithoutIcc","URL","createObjectURL","revokeObjectURL","format","newBlob","value","isExifOrientationApplied","message"],"sources":["/Users/kavinth/Documents/GitHub/Smart-Alert/Smart-Alert-new/frontend/node_modules/@uploadcare/image-shrink/dist/esm/index.browser.mjs"],"sourcesContent":["// TODO: unwrap promises\nconst readJpegChunks = () => {\n    const stack = [];\n    const promiseReadJpegChunks = (blob) => new Promise((resolve, reject) => {\n        let pos = 2;\n        const readToView = (blob, cb) => {\n            const reader = new FileReader();\n            reader.addEventListener('load', () => {\n                cb(new DataView(reader.result));\n            });\n            reader.addEventListener('error', (e) => {\n                reject(`Reader error: ${e}`);\n            });\n            reader.readAsArrayBuffer(blob);\n        };\n        const readNext = () => readToView(blob.slice(pos, pos + 128), (view) => {\n            let i, j, ref;\n            for (i = j = 0, ref = view.byteLength; ref >= 0 ? j < ref : j > ref; i = ref >= 0 ? ++j : --j) {\n                if (view.getUint8(i) === 0xff) {\n                    pos += i;\n                    break;\n                }\n            }\n            readNextChunk();\n        });\n        const readNextChunk = () => {\n            const startPos = pos;\n            return readToView(blob.slice(pos, (pos += 4)), (view) => {\n                if (view.byteLength !== 4 || view.getUint8(0) !== 0xff) {\n                    reject('Corrupted');\n                    return;\n                }\n                const marker = view.getUint8(1);\n                if (marker === 0xda) {\n                    resolve(true);\n                    return;\n                }\n                const length = view.getUint16(2) - 2;\n                return readToView(blob.slice(pos, (pos += length)), (view) => {\n                    if (view.byteLength !== length) {\n                        reject('Corrupted');\n                        return;\n                    }\n                    stack.push({ startPos, length, marker, view });\n                    readNext();\n                });\n            });\n        };\n        if (!(FileReader && DataView)) {\n            reject('Not Support');\n        }\n        readToView(blob.slice(0, 2), (view) => {\n            if (view.getUint16(0) !== 0xffd8) {\n                reject('Not jpeg');\n            }\n            readNext();\n        });\n    });\n    return {\n        stack,\n        promiseReadJpegChunks\n    };\n};\n\nconst getIccProfile = async (blob) => {\n    const iccProfile = [];\n    const { promiseReadJpegChunks, stack } = readJpegChunks();\n    await promiseReadJpegChunks(blob);\n    stack.forEach(({ marker, view }) => {\n        if (marker === 0xe2) {\n            if (\n            // check for \"ICC_PROFILE\\0\"\n            view.getUint32(0) === 0x4943435f &&\n                view.getUint32(4) === 0x50524f46 &&\n                view.getUint32(8) === 0x494c4500) {\n                iccProfile.push(view);\n            }\n        }\n    });\n    return iccProfile;\n};\n\nconst replaceJpegChunk = async (blob, marker, chunks) => {\n    {\n        const oldChunkPos = [];\n        const oldChunkLength = [];\n        const { promiseReadJpegChunks, stack } = readJpegChunks();\n        await promiseReadJpegChunks(blob);\n        stack.forEach((chunk) => {\n            if (chunk.marker === marker) {\n                oldChunkPos.push(chunk.startPos);\n                return oldChunkLength.push(chunk.length);\n            }\n        });\n        const newChunks = [blob.slice(0, 2)];\n        for (const chunk of chunks) {\n            const intro = new DataView(new ArrayBuffer(4));\n            intro.setUint16(0, 0xff00 + marker);\n            intro.setUint16(2, chunk.byteLength + 2);\n            newChunks.push(intro.buffer);\n            newChunks.push(chunk);\n        }\n        let pos = 2;\n        for (let i = 0; i < oldChunkPos.length; i++) {\n            if (oldChunkPos[i] > pos) {\n                newChunks.push(blob.slice(pos, oldChunkPos[i]));\n            }\n            pos = oldChunkPos[i] + oldChunkLength[i] + 4;\n        }\n        newChunks.push(blob.slice(pos, blob.size));\n        return new Blob(newChunks, {\n            type: blob.type\n        });\n    }\n};\n\nconst MARKER = 0xe2;\nconst replaceIccProfile = (blob, iccProfiles) => {\n    return replaceJpegChunk(blob, MARKER, iccProfiles.map((chunk) => chunk.buffer));\n};\n\nconst stripIccProfile = async (blob) => {\n    try {\n        return await replaceIccProfile(blob, []);\n    }\n    catch (e) {\n        throw new Error(`Failed to strip ICC profile: ${e}`);\n    }\n};\n\nconst canvasToBlob = (canvas, type, quality) => {\n    return new Promise((resolve, reject) => {\n        const callback = (blob) => {\n            if (!blob) {\n                reject('Failed to convert canvas to blob');\n                return;\n            }\n            resolve(blob);\n        };\n        canvas.toBlob(callback, type, quality);\n        canvas.width = canvas.height = 1;\n    });\n};\n\nconst createCanvas = () => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    return {\n        canvas,\n        ctx\n    };\n};\n\nconst hasTransparency = (img) => {\n    const canvasSize = 50;\n    // Create a canvas element and get 2D rendering context\n    const { ctx, canvas } = createCanvas();\n    canvas.width = canvas.height = canvasSize;\n    // Draw the image onto the canvas\n    ctx.drawImage(img, 0, 0, canvasSize, canvasSize);\n    // Get the image data\n    const imageData = ctx.getImageData(0, 0, canvasSize, canvasSize).data;\n    // Reset the canvas dimensions\n    canvas.width = canvas.height = 1;\n    // Check for transparency in the alpha channel\n    for (let i = 3; i < imageData.length; i += 4) {\n        if (imageData[i] < 254) {\n            return true;\n        }\n    }\n    // No transparency found\n    return false;\n};\n\nconst getExif = async (blob) => {\n    let exif = null;\n    const { promiseReadJpegChunks, stack } = readJpegChunks();\n    await promiseReadJpegChunks(blob);\n    stack.forEach(({ marker, view }) => {\n        if (!exif && marker === 0xe1) {\n            if (view.byteLength >= 14) {\n                if (\n                // check for \"Exif\\0\"\n                view.getUint32(0) === 0x45786966 &&\n                    view.getUint16(4) === 0) {\n                    exif = view;\n                    return;\n                }\n            }\n        }\n    });\n    return exif;\n};\n\n// 2x1 pixel image 90CW rotated with orientation header\nconst base64ImageSrc = 'data:image/jpg;base64,' +\n    '/9j/4AAQSkZJRgABAQEASABIAAD/4QA6RXhpZgAATU0AKgAAAAgAAwESAAMAAAABAAYAAAEo' +\n    'AAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAD/2wBDAP//////////////////////////////' +\n    '////////////////////////////////////////////////////////wAALCAABAAIBASIA' +\n    '/8QAJgABAAAAAAAAAAAAAAAAAAAAAxABAAAAAAAAAAAAAAAAAAAAAP/aAAgBAQAAPwBH/9k=';\nlet isApplied = undefined;\nconst isBrowserApplyExifOrientation = () => {\n    return new Promise((resolve) => {\n        if (isApplied !== undefined) {\n            resolve(isApplied);\n        }\n        else {\n            const image = new Image();\n            image.addEventListener('load', () => {\n                isApplied = image.naturalWidth < image.naturalHeight;\n                image.src = '//:0';\n                resolve(isApplied);\n            });\n            image.src = base64ImageSrc;\n        }\n    });\n};\n\nconst findExifOrientation = (exif, exifCallback) => {\n    let j, little, offset, ref;\n    if (!exif ||\n        exif.byteLength < 14 ||\n        exif.getUint32(0) !== 0x45786966 ||\n        exif.getUint16(4) !== 0) {\n        return;\n    }\n    if (exif.getUint16(6) === 0x4949) {\n        little = true;\n    }\n    else if (exif.getUint16(6) === 0x4d4d) {\n        little = false;\n    }\n    else {\n        return;\n    }\n    if (exif.getUint16(8, little) !== 0x002a) {\n        return;\n    }\n    offset = 8 + exif.getUint32(10, little);\n    const count = exif.getUint16(offset - 2, little);\n    for (j = 0, ref = count; ref >= 0 ? j < ref : j > ref; ref >= 0 ? ++j : --j) {\n        if (exif.byteLength < offset + 10) {\n            return;\n        }\n        if (exif.getUint16(offset, little) === 0x0112) {\n            exifCallback(offset + 8, little);\n        }\n        offset += 12;\n    }\n};\n\nconst setExifOrientation = (exif, orientation) => {\n    findExifOrientation(exif, (offset, littleEndian) => exif.setUint16(offset, orientation, littleEndian));\n};\nconst replaceExif = async (blob, exif, isExifApplied) => {\n    if (isExifApplied) {\n        setExifOrientation(exif, 1);\n    }\n    return replaceJpegChunk(blob, 0xe1, [exif.buffer]);\n};\n\nconst processImage = (image, src) => {\n    return new Promise((resolve, reject) => {\n        if (src) {\n            image.src = src;\n        }\n        if (image.complete) {\n            resolve(image);\n        }\n        else {\n            image.addEventListener('load', () => {\n                resolve(image);\n            });\n            image.addEventListener('error', () => {\n                reject(new Error('Failed to load image. Probably not an image.'));\n            });\n        }\n    });\n};\nconst imageLoader = (image) => {\n    return processImage(new Image(), image);\n};\n\nconst allowLayers = [\n    1, // L (black-white)\n    3 // RGB\n];\n\nconst markers = [\n    0xc0, // (\"SOF0\", \"Baseline DCT\", SOF)\n    0xc1, // (\"SOF1\", \"Extended Sequential DCT\", SOF)\n    0xc2, // (\"SOF2\", \"Progressive DCT\", SOF)\n    0xc3, // (\"SOF3\", \"Spatial lossless\", SOF)\n    0xc5, // (\"SOF5\", \"Differential sequential DCT\", SOF)\n    0xc6, // (\"SOF6\", \"Differential progressive DCT\", SOF)\n    0xc7, // (\"SOF7\", \"Differential spatial\", SOF)\n    0xc9, // (\"SOF9\", \"Extended sequential DCT (AC)\", SOF)\n    0xca, // (\"SOF10\", \"Progressive DCT (AC)\", SOF)\n    0xcb, // (\"SOF11\", \"Spatial lossless DCT (AC)\", SOF)\n    0xcd, // (\"SOF13\", \"Differential sequential DCT (AC)\", SOF)\n    0xce, // (\"SOF14\", \"Differential progressive DCT (AC)\", SOF)\n    0xcf // (\"SOF15\", \"Differential spatial (AC)\", SOF)\n];\n\nconst sizes = {\n    squareSide: [\n        // Safari (iOS < 9, ram >= 256)\n        // We are supported mobile safari < 9 since widget v2, by 5 Mpx limit\n        // so it's better to continue support despite the absence of this browser in the support table\n        Math.floor(Math.sqrt(5 * 1000 * 1000)),\n        // IE Mobile (Windows Phone 8.x)\n        // Safari (iOS >= 9)\n        4096,\n        // IE 9 (Win)\n        8192,\n        // Firefox 63 (Mac, Win)\n        11180,\n        // Chrome 68 (Android 6)\n        10836,\n        // Chrome 68 (Android 5)\n        11402,\n        // Chrome 68 (Android 7.1-9)\n        14188,\n        // Chrome 70 (Mac, Win)\n        // Chrome 68 (Android 4.4)\n        // Edge 17 (Win)\n        // Safari 7-12 (Mac)\n        16384\n    ],\n    dimension: [\n        // IE Mobile (Windows Phone 8.x)\n        4096,\n        // IE 9 (Win)\n        8192,\n        // Edge 17 (Win)\n        // IE11 (Win)\n        16384,\n        // Chrome 70 (Mac, Win)\n        // Chrome 68 (Android 4.4-9)\n        // Firefox 63 (Mac, Win)\n        32767,\n        // Chrome 83 (Mac, Win)\n        // Safari 7-12 (Mac)\n        // Safari (iOS 9-12)\n        // Actually Safari has a much bigger limits - 4194303 of width and 8388607 of height,\n        // but we will not use them\n        65535\n    ]\n};\n\nconst shouldSkipShrink = async (blob) => {\n    let skip = false;\n    const { promiseReadJpegChunks, stack } = readJpegChunks();\n    return await promiseReadJpegChunks(blob)\n        .then(() => {\n        stack.forEach(({ marker, view }) => {\n            if (!skip && markers.indexOf(marker) >= 0) {\n                const layer = view.getUint8(5);\n                if (allowLayers.indexOf(layer) < 0) {\n                    skip = true;\n                }\n            }\n        });\n        return skip;\n    })\n        .catch(() => skip);\n};\n\nconst memoize = (fn, serializer) => {\n    const cache = {};\n    return (...args) => {\n        const key = serializer(args, cache);\n        return key in cache ? cache[key] : (cache[key] = fn(...args));\n    };\n};\n/**\n * Memoization key serealizer, that prevents unnecessary canvas tests. No need\n * to make test if we know that:\n *\n * - Browser supports higher canvas size\n * - Browser doesn't support lower canvas size\n */\nconst memoKeySerializer = (args, cache) => {\n    const [w] = args;\n    const cachedWidths = Object.keys(cache)\n        .map((val) => parseInt(val, 10))\n        .sort((a, b) => a - b);\n    for (let i = 0; i < cachedWidths.length; i++) {\n        const cachedWidth = cachedWidths[i];\n        const isSupported = !!cache[cachedWidth];\n        // higher supported canvas size, return it\n        if (cachedWidth > w && isSupported) {\n            return cachedWidth;\n        }\n        // lower unsupported canvas size, return it\n        if (cachedWidth < w && !isSupported) {\n            return cachedWidth;\n        }\n    }\n    // use canvas width as the key,\n    // because we're doing dimension test by width - [dimension, 1]\n    return w;\n};\n\n// add constants\nconst TestPixel = {\n    R: 55,\n    G: 110,\n    B: 165,\n    A: 255\n};\nconst FILL_STYLE = `rgba(${TestPixel.R}, ${TestPixel.G}, ${TestPixel.B}, ${TestPixel.A / 255})`;\nconst canvasTest = (width, height) => {\n    try {\n        const fill = [width - 1, height - 1, 1, 1]; // x, y, width, height\n        const { canvas: cropCvs, ctx: cropCtx } = createCanvas();\n        cropCvs.width = 1;\n        cropCvs.height = 1;\n        const { canvas: testCvs, ctx: testCtx } = createCanvas();\n        testCvs.width = width;\n        testCvs.height = height;\n        if (testCtx) {\n            testCtx.fillStyle = FILL_STYLE;\n            testCtx.fillRect(...fill);\n            // Render the test pixel in the bottom-right corner of the\n            // test canvas in the top-left of the 1x1 crop canvas. This\n            // dramatically reducing the time for getImageData to complete.\n            cropCtx.drawImage(testCvs, width - 1, height - 1, 1, 1, 0, 0, 1, 1);\n        }\n        const imageData = cropCtx && cropCtx.getImageData(0, 0, 1, 1).data;\n        let isTestPass = false;\n        if (imageData) {\n            // On IE10, imageData have type CanvasPixelArray, not Uint8ClampedArray.\n            // CanvasPixelArray supports index access operations only.\n            // Array buffers can't be destructuredd and compared with JSON.stringify\n            isTestPass =\n                imageData[0] === TestPixel.R &&\n                    imageData[1] === TestPixel.G &&\n                    imageData[2] === TestPixel.B &&\n                    imageData[3] === TestPixel.A;\n        }\n        testCvs.width = testCvs.height = 1;\n        return isTestPass;\n    }\n    catch (e) {\n        console.error(`Failed to test for max canvas size of ${width}x${height}.`);\n        return false;\n    }\n};\n\nfunction wrapAsync(fn) {\n    return (...args) => {\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                const result = fn(...args);\n                resolve(result);\n            }, 0);\n        });\n    };\n}\nconst squareTest = wrapAsync(memoize(canvasTest, memoKeySerializer));\nconst dimensionTest = wrapAsync(memoize(canvasTest, memoKeySerializer));\nconst testCanvasSize = async (w, h) => {\n    const testSquareSide = sizes.squareSide.find((side) => side * side >= w * h);\n    const testDimension = sizes.dimension.find((side) => side >= w && side >= h);\n    if (!testSquareSide || !testDimension) {\n        throw new Error('Not supported');\n    }\n    const [squareSupported, dimensionSupported] = await Promise.all([\n        squareTest(testSquareSide, testSquareSide),\n        dimensionTest(testDimension, 1)\n    ]);\n    if (squareSupported && dimensionSupported) {\n        return true;\n    }\n    else {\n        throw new Error('Not supported');\n    }\n};\n\nconst canvasResize = async (img, w, h) => {\n    try {\n        const { ctx, canvas } = createCanvas();\n        canvas.width = w;\n        canvas.height = h;\n        ctx.imageSmoothingQuality = 'high';\n        ctx.drawImage(img, 0, 0, w, h);\n        if (img instanceof HTMLImageElement) {\n            img.src = '//:0'; // free memory\n        }\n        if (img instanceof HTMLCanvasElement) {\n            img.width = img.height = 1; // free memory\n        }\n        return canvas;\n    }\n    catch (e) {\n        throw new Error('Canvas resize error', { cause: e });\n    }\n};\n\n/**\n * Native high-quality canvas resampling\n *\n * Browser support:\n * https://caniuse.com/mdn-api_canvasrenderingcontext2d_imagesmoothingenabled\n * Target dimensions expected to be supported by browser.\n */\nconst native = ({ img, targetW, targetH }) => canvasResize(img, targetW, targetH);\n\n/**\n * Goes from target to source by step, the last incomplete step is dropped.\n * Always returns at least one step - target. Source step is not included.\n * Sorted descending.\n *\n * Example with step = 0.71, source = 2000, target = 400 400 (target) <- 563 <-\n * 793 <- 1117 <- 1574 (dropped) <- [2000 (source)]\n */\nconst calcShrinkSteps = function ({ sourceW, targetW, targetH, step }) {\n    const steps = [];\n    let sW = targetW;\n    let sH = targetH;\n    // result should include at least one target step,\n    // even if abs(source - target) < step * source\n    // just to be sure nothing will break\n    // if the original resolution / target resolution condition changes\n    do {\n        steps.push([sW, sH]);\n        sW = Math.round(sW / step);\n        sH = Math.round(sH / step);\n    } while (sW < sourceW * step);\n    return steps.reverse();\n};\n/**\n * Fallback resampling algorithm\n *\n * Reduces dimensions by step until reaches target dimensions, this gives a\n * better output quality than one-step method\n *\n * Target dimensions expected to be supported by browser, unsupported steps will\n * be dropped.\n */\nconst fallback = ({ img, sourceW, targetW, targetH, step }) => {\n    const steps = calcShrinkSteps({ sourceW, targetW, targetH, step });\n    return steps.reduce((chain, [w, h], idx) => {\n        return chain.then((canvas) => {\n            return testCanvasSize(w, h)\n                .then(() => canvasResize(canvas, w, h))\n                .catch(() => {\n                if (idx === steps.length - 1) {\n                    // If the last step is failed then we assume that we can't shrink the image at all\n                    throw new Error('Not supported');\n                }\n                return canvas;\n            });\n        });\n    }, Promise.resolve(img));\n};\n\nconst isIOS = () => {\n    if (/iPad|iPhone|iPod/.test(navigator.platform)) {\n        return true;\n    }\n    else {\n        return (navigator.maxTouchPoints &&\n            navigator.maxTouchPoints > 2 &&\n            /MacIntel/.test(navigator.platform));\n    }\n};\nconst isIpadOS = navigator.maxTouchPoints &&\n    navigator.maxTouchPoints > 2 &&\n    /MacIntel/.test(navigator.platform);\n\nconst STEP = 0.71; // should be > sqrt(0.5)\nconst shrinkImage = (img, settings) => {\n    // do not shrink image if original resolution / target resolution ratio falls behind 2.0\n    if (img.width * STEP * img.height * STEP < settings.size) {\n        throw new Error('Not required');\n    }\n    const sourceW = img.width;\n    const sourceH = img.height;\n    const ratio = sourceW / sourceH;\n    // target size shouldn't be greater than settings.size in any case\n    const targetW = Math.floor(Math.sqrt(settings.size * ratio));\n    const targetH = Math.floor(settings.size / Math.sqrt(settings.size * ratio));\n    // we test the last step because we can skip all intermediate steps\n    return testCanvasSize(targetW, targetH)\n        .then(() => {\n        const { ctx } = createCanvas();\n        const supportNative = 'imageSmoothingQuality' in ctx;\n        // native scaling on ios gives blurry results\n        // TODO: check if it's still true\n        const useNativeScaling = supportNative && !isIOS() && !isIpadOS;\n        return useNativeScaling\n            ? native({ img, targetW, targetH })\n            : fallback({ img, sourceW, targetW, targetH, step: STEP });\n    })\n        .catch(() => Promise.reject('Not supported'));\n};\n\nconst shrinkFile = async (inputBlob, settings) => {\n    try {\n        const shouldSkip = await shouldSkipShrink(inputBlob);\n        if (shouldSkip) {\n            throw new Error('Should skipped');\n        }\n        // Try to extract EXIF and ICC profile\n        const exifResults = await Promise.allSettled([\n            getExif(inputBlob),\n            isBrowserApplyExifOrientation(),\n            getIccProfile(inputBlob)\n        ]);\n        const isRejected = exifResults.some((result) => result.status === 'rejected');\n        // If any of the promises is rejected, this is not a JPEG image\n        const isJPEG = !isRejected;\n        const [exifResult, isExifOrientationAppliedResult, iccProfileResult] = exifResults;\n        // Load blob into the image\n        const inputBlobWithoutIcc = await stripIccProfile(inputBlob).catch(() => inputBlob);\n        const image = await imageLoader(URL.createObjectURL(inputBlobWithoutIcc));\n        URL.revokeObjectURL(image.src);\n        // Shrink the image\n        const canvas = await shrinkImage(image, settings);\n        let format = 'image/jpeg';\n        let quality = settings?.quality || 0.8;\n        if (!isJPEG && hasTransparency(canvas)) {\n            format = 'image/png';\n            quality = undefined;\n        }\n        // Convert canvas to blob\n        let newBlob = await canvasToBlob(canvas, format, quality);\n        // Set EXIF for the new blob\n        if (isJPEG && exifResult.status === 'fulfilled' && exifResult.value) {\n            const exif = exifResult.value;\n            const isExifOrientationApplied = isExifOrientationAppliedResult.status === 'fulfilled'\n                ? isExifOrientationAppliedResult.value\n                : false;\n            newBlob = await replaceExif(newBlob, exif, isExifOrientationApplied);\n            // TODO: should we continue shrink if failed to replace EXIF?\n            // .catch(() => newBlob)\n        }\n        // Set ICC profile for the new blob\n        if (isJPEG &&\n            iccProfileResult.status === 'fulfilled' &&\n            iccProfileResult.value.length > 0) {\n            newBlob = await replaceIccProfile(newBlob, iccProfileResult.value);\n            // TODO: should we continue shrink if failed to replace ICC?\n            // .catch(() => newBlob)\n        }\n        return newBlob;\n    }\n    catch (e) {\n        let message;\n        if (e instanceof Error) {\n            message = e.message;\n        }\n        if (typeof e === 'string') {\n            message = e;\n        }\n        throw new Error(`Failed to shrink image. ${message ? `Message: \"${message}\".` : ''}`, { cause: e });\n    }\n};\n\nexport { shrinkFile };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}