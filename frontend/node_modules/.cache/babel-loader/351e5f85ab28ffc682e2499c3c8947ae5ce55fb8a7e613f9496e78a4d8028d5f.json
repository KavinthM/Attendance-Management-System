{"ast":null,"code":"// @ts-check\n\n// TODO: Here is troubles with tsd: it can't resolve types from `@uploadcare/cname-prefix/async` due to unsupported bundler moduleResolution.\n// @ts-ignore\nimport { getPrefixedCdnBaseAsync, isPrefixedCdnBase } from '@uploadcare/cname-prefix/async';\nimport { deserializeCsv, serializeCsv } from '../utils/comma-separated.js';\nimport { DEFAULT_CDN_CNAME } from './initialConfig.js';\nimport { isPromiseLike } from '../../utils/isPromiseLike.js';\n\n/**\n * @template {keyof import('../../types').ConfigType} TKey\n * @template {Exclude<keyof import('../../types').ConfigType, TKey>[]} TDeps\n * @typedef {Object} ComputedPropertyDeclaration\n * @property {TKey} key\n * @property {TDeps} deps\n * @property {(\n *   args: Record<TKey, import('../../types').ConfigType[TKey]> & {\n *     [K in TDeps[number]]: import('../../types').ConfigType[K];\n *   },\n * ) => import('../../types').ConfigType[TKey] | Promise<import('../../types').ConfigType[TKey]>} fn\n */\n\n/**\n * @template {keyof import('../../types').ConfigType} TKey\n * @template {Exclude<keyof import('../../types').ConfigType, TKey>[]} TDeps\n * @param {ComputedPropertyDeclaration<TKey, TDeps>} declaration\n */\nfunction defineComputedProperty(declaration) {\n  return declaration;\n}\nconst COMPUTED_PROPERTIES = [defineComputedProperty({\n  key: 'cameraModes',\n  deps: ['enableVideoRecording'],\n  fn: ({\n    cameraModes,\n    enableVideoRecording\n  }) => {\n    if (enableVideoRecording === null) {\n      return cameraModes;\n    }\n    let cameraModesCsv = deserializeCsv(cameraModes);\n    if (enableVideoRecording && !cameraModesCsv.includes('video')) {\n      cameraModesCsv = cameraModesCsv.concat('video');\n    } else if (!enableVideoRecording) {\n      cameraModesCsv = cameraModesCsv.filter(mode => mode !== 'video');\n    }\n    return serializeCsv(cameraModesCsv);\n  }\n}), defineComputedProperty({\n  key: 'cameraModes',\n  deps: ['defaultCameraMode'],\n  fn: ({\n    cameraModes,\n    defaultCameraMode\n  }) => {\n    if (defaultCameraMode === null) {\n      return cameraModes;\n    }\n    let cameraModesCsv = deserializeCsv(cameraModes);\n    cameraModesCsv = cameraModesCsv.sort((a, b) => {\n      if (a === defaultCameraMode) return -1;\n      if (b === defaultCameraMode) return 1;\n      return 0;\n    });\n    return serializeCsv(cameraModesCsv);\n  }\n}), defineComputedProperty({\n  key: 'cdnCname',\n  deps: ['pubkey', 'cdnCnamePrefixed'],\n  fn: ({\n    pubkey,\n    cdnCname,\n    cdnCnamePrefixed\n  }) => {\n    if (pubkey && (cdnCname === DEFAULT_CDN_CNAME || isPrefixedCdnBase(cdnCname, cdnCnamePrefixed))) {\n      return getPrefixedCdnBaseAsync(pubkey, cdnCnamePrefixed);\n    }\n    return cdnCname;\n  }\n})];\n\n/**\n * @template {keyof import('../../types').ConfigType} T\n * @param {{\n *   key: T;\n *   setValue: <TSetValue extends keyof import('../../types').ConfigType>(\n *     key: TSetValue,\n *     value: import('../../types').ConfigType[TSetValue],\n *   ) => void;\n *   getValue: <TGetValue extends keyof import('../../types').ConfigType>(\n *     key: TGetValue,\n *   ) => import('../../types').ConfigType[TGetValue];\n * }} options\n */\nexport const runSideEffects = ({\n  key,\n  setValue,\n  getValue\n}) => {\n  for (const computed of COMPUTED_PROPERTIES) {\n    if (computed.deps.includes(key)) {\n      const args = {\n        [computed.key]: getValue(computed.key),\n        ...computed.deps.reduce((acc, dep) => ({\n          ...acc,\n          [dep]: getValue(dep)\n        }),\n        /**\n         * @type {Record<typeof computed.key, import('../../types').ConfigType[typeof computed.key]> & {\n         *   [K in (typeof computed.deps)[number]]: import('../../types').ConfigType[K];\n         * }}\n         */\n        {})\n      };\n      const result = computed.fn(args);\n      if (isPromiseLike(result)) {\n        const prevValue = getValue(computed.key);\n        result.then(resolvedValue => {\n          const currentValue = getValue(computed.key);\n          if (currentValue === prevValue) {\n            setValue(computed.key, resolvedValue);\n          }\n        }).catch(error => {\n          console.error(`Failed to compute value for \"${computed.key}\"`, error);\n        });\n      } else {\n        setValue(computed.key, result);\n      }\n    }\n  }\n};","map":{"version":3,"names":["getPrefixedCdnBaseAsync","isPrefixedCdnBase","deserializeCsv","serializeCsv","DEFAULT_CDN_CNAME","isPromiseLike","defineComputedProperty","declaration","COMPUTED_PROPERTIES","key","deps","fn","cameraModes","enableVideoRecording","cameraModesCsv","includes","concat","filter","mode","defaultCameraMode","sort","a","b","pubkey","cdnCname","cdnCnamePrefixed","runSideEffects","setValue","getValue","computed","args","reduce","acc","dep","result","prevValue","then","resolvedValue","currentValue","catch","error","console"],"sources":["/Users/kavinth/Documents/GitHub/Smart-Alert/Smart-Alert-new/frontend/node_modules/@uploadcare/file-uploader/blocks/Config/side-effects.js"],"sourcesContent":["// @ts-check\n\n// TODO: Here is troubles with tsd: it can't resolve types from `@uploadcare/cname-prefix/async` due to unsupported bundler moduleResolution.\n// @ts-ignore\nimport { getPrefixedCdnBaseAsync, isPrefixedCdnBase } from '@uploadcare/cname-prefix/async';\nimport { deserializeCsv, serializeCsv } from '../utils/comma-separated.js';\nimport { DEFAULT_CDN_CNAME } from './initialConfig.js';\nimport { isPromiseLike } from '../../utils/isPromiseLike.js';\n\n/**\n * @template {keyof import('../../types').ConfigType} TKey\n * @template {Exclude<keyof import('../../types').ConfigType, TKey>[]} TDeps\n * @typedef {Object} ComputedPropertyDeclaration\n * @property {TKey} key\n * @property {TDeps} deps\n * @property {(\n *   args: Record<TKey, import('../../types').ConfigType[TKey]> & {\n *     [K in TDeps[number]]: import('../../types').ConfigType[K];\n *   },\n * ) => import('../../types').ConfigType[TKey] | Promise<import('../../types').ConfigType[TKey]>} fn\n */\n\n/**\n * @template {keyof import('../../types').ConfigType} TKey\n * @template {Exclude<keyof import('../../types').ConfigType, TKey>[]} TDeps\n * @param {ComputedPropertyDeclaration<TKey, TDeps>} declaration\n */\nfunction defineComputedProperty(declaration) {\n  return declaration;\n}\n\nconst COMPUTED_PROPERTIES = [\n  defineComputedProperty({\n    key: 'cameraModes',\n    deps: ['enableVideoRecording'],\n    fn: ({ cameraModes, enableVideoRecording }) => {\n      if (enableVideoRecording === null) {\n        return cameraModes;\n      }\n      let cameraModesCsv = deserializeCsv(cameraModes);\n      if (enableVideoRecording && !cameraModesCsv.includes('video')) {\n        cameraModesCsv = cameraModesCsv.concat('video');\n      } else if (!enableVideoRecording) {\n        cameraModesCsv = cameraModesCsv.filter((mode) => mode !== 'video');\n      }\n      return serializeCsv(cameraModesCsv);\n    },\n  }),\n  defineComputedProperty({\n    key: 'cameraModes',\n    deps: ['defaultCameraMode'],\n    fn: ({ cameraModes, defaultCameraMode }) => {\n      if (defaultCameraMode === null) {\n        return cameraModes;\n      }\n      let cameraModesCsv = deserializeCsv(cameraModes);\n      cameraModesCsv = cameraModesCsv.sort((a, b) => {\n        if (a === defaultCameraMode) return -1;\n        if (b === defaultCameraMode) return 1;\n        return 0;\n      });\n      return serializeCsv(cameraModesCsv);\n    },\n  }),\n  defineComputedProperty({\n    key: 'cdnCname',\n    deps: ['pubkey', 'cdnCnamePrefixed'],\n    fn: ({ pubkey, cdnCname, cdnCnamePrefixed }) => {\n      if (pubkey && (cdnCname === DEFAULT_CDN_CNAME || isPrefixedCdnBase(cdnCname, cdnCnamePrefixed))) {\n        return getPrefixedCdnBaseAsync(pubkey, cdnCnamePrefixed);\n      }\n\n      return cdnCname;\n    },\n  }),\n];\n\n/**\n * @template {keyof import('../../types').ConfigType} T\n * @param {{\n *   key: T;\n *   setValue: <TSetValue extends keyof import('../../types').ConfigType>(\n *     key: TSetValue,\n *     value: import('../../types').ConfigType[TSetValue],\n *   ) => void;\n *   getValue: <TGetValue extends keyof import('../../types').ConfigType>(\n *     key: TGetValue,\n *   ) => import('../../types').ConfigType[TGetValue];\n * }} options\n */\nexport const runSideEffects = ({ key, setValue, getValue }) => {\n  for (const computed of COMPUTED_PROPERTIES) {\n    if (computed.deps.includes(key)) {\n      const args = {\n        [computed.key]: getValue(computed.key),\n        ...computed.deps.reduce(\n          (acc, dep) => ({\n            ...acc,\n            [dep]: getValue(dep),\n          }),\n          /**\n           * @type {Record<typeof computed.key, import('../../types').ConfigType[typeof computed.key]> & {\n           *   [K in (typeof computed.deps)[number]]: import('../../types').ConfigType[K];\n           * }}\n           */ ({}),\n        ),\n      };\n      const result = computed.fn(args);\n      if (isPromiseLike(result)) {\n        const prevValue = getValue(computed.key);\n        result\n          .then((resolvedValue) => {\n            const currentValue = getValue(computed.key);\n            if (currentValue === prevValue) {\n              setValue(computed.key, resolvedValue);\n            }\n          })\n          .catch((error) => {\n            console.error(`Failed to compute value for \"${computed.key}\"`, error);\n          });\n      } else {\n        setValue(computed.key, result);\n      }\n    }\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}