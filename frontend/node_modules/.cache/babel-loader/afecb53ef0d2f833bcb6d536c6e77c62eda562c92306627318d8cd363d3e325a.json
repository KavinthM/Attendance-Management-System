{"ast":null,"code":"// @ts-check\nimport { Block } from '../../abstract/Block.js';\nimport { initialConfig } from './initialConfig.js';\nimport { sharedConfigKey } from '../../abstract/sharedConfigKey.js';\nimport { toKebabCase } from '../../utils/toKebabCase.js';\nimport { normalizeConfigValue } from './normalizeConfigValue.js';\nimport { runAssertions } from './assertions.js';\nimport { runSideEffects } from './side-effects.js';\nconst allConfigKeys = /** @type {(keyof import('../../types').ConfigType)[]} */[\n// \"debug\" option should go first to be able to print debug messages from the very beginning\n...new Set(['debug', ...Object.keys(initialConfig)])];\n\n/**\n * Config keys that can't be passed as attribute (because they are object or function)\n *\n * @type {[\n *   'metadata',\n *   'localeDefinitionOverride',\n *   'secureUploadsSignatureResolver',\n *   'secureDeliveryProxyUrlResolver',\n *   'iconHrefResolver',\n *   'fileValidators',\n *   'collectionValidators',\n *   'mediaRecorderOptions',\n * ]}\n */\nexport const complexConfigKeys = ['metadata', 'localeDefinitionOverride', 'secureUploadsSignatureResolver', 'secureDeliveryProxyUrlResolver', 'iconHrefResolver', 'fileValidators', 'collectionValidators', 'mediaRecorderOptions'];\n\n/** @type {(key: keyof import('../../types').ConfigType) => key is keyof import('../../types').ConfigComplexType} */\nconst isComplexKey = key => complexConfigKeys.includes(key);\n\n/** Config keys that can be passed as attribute */\nconst plainConfigKeys = /** @type {(keyof import('../../types').ConfigPlainType)[]} */\nallConfigKeys.filter(key => !isComplexKey(key));\n\n/**\n * Mapping of attribute names to config keys Kebab-case and lowercase are supported. lowercase could be used by\n * frameworks like vue and react.\n */\nconst attrKeyMapping = /** @type {Record<keyof import('../../types').ConfigAttributesType, keyof import('../../types').ConfigPlainType>} */{\n  ...Object.fromEntries(plainConfigKeys.map(key => [toKebabCase(key), key])),\n  ...Object.fromEntries(plainConfigKeys.map(key => [key.toLowerCase(), key]))\n};\n\n/** Mapping of attribute names to state */\nconst attrStateMapping = /** @type {Record<keyof import('../../types').ConfigAttributesType, string>} */{\n  ...Object.fromEntries(plainConfigKeys.map(key => [toKebabCase(key), sharedConfigKey(key)])),\n  ...Object.fromEntries(plainConfigKeys.map(key => [key.toLowerCase(), sharedConfigKey(key)]))\n};\n\n/** @param {string} key */\nconst getLocalPropName = key => '__' + key;\nclass ConfigClass extends Block {\n  requireCtxName = true;\n  constructor() {\n    super();\n\n    /** @type {Block['init$'] & import('../../types').ConfigType} */\n    this.init$ = {\n      ...this.init$,\n      ...Object.fromEntries(Object.entries(initialConfig).map(([key, value]) => [sharedConfigKey(/** @type {keyof import('../../types').ConfigType} */key), value]))\n    };\n  }\n\n  /**\n   * @private\n   * @param {keyof import('../../types').ConfigType} key\n   * @param {unknown} value\n   */\n  _flushValueToAttribute(key, value) {\n    if (plainConfigKeys.includes(key)) {\n      // Flush the value to the DOM attributes\n      const attrs = [...new Set([toKebabCase(key), key.toLowerCase()])];\n      for (const attr of attrs) {\n        if (typeof value === 'undefined' || value === null) {\n          this.removeAttribute(attr);\n        } else if (this.getAttribute(attr) !== value.toString()) {\n          this.setAttribute(attr, value.toString());\n        }\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {keyof import('../../types').ConfigType} key\n   * @param {unknown} value\n   */\n  _flushValueToState(key, value) {\n    if (this.$[sharedConfigKey(key)] !== value) {\n      if (typeof value === 'undefined' || value === null) {\n        this.$[sharedConfigKey(key)] = initialConfig[key];\n      } else {\n        this.$[sharedConfigKey(key)] = value;\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {keyof import('../../types').ConfigType} key\n   * @param {unknown} value\n   */\n  _setValue(key, value) {\n    const anyThis = /** @type {typeof this & any} */this;\n    const normalizedValue = normalizeConfigValue(key, value);\n    const localPropName = getLocalPropName(key);\n    if (anyThis[localPropName] === normalizedValue) return;\n    this._assertSameValueDifferentReference(key, anyThis[localPropName], normalizedValue);\n    anyThis[localPropName] = normalizedValue;\n\n    // Flush the value to the state\n    this._flushValueToAttribute(key, normalizedValue);\n    this._flushValueToState(key, normalizedValue);\n    this.debugPrint(`[uc-config] \"${key}\"`, normalizedValue);\n    runAssertions(this.cfg);\n    runSideEffects({\n      key,\n      setValue: this._setValue.bind(this),\n      getValue: this._getValue.bind(this)\n    });\n  }\n\n  /**\n   * @private\n   * @param {keyof import('../../types').ConfigType} key\n   */\n  _getValue(key) {\n    const anyThis = /** @type {typeof this & any} */this;\n    const localPropName = getLocalPropName(key);\n    return anyThis[localPropName] ?? this.$[sharedConfigKey(key)];\n  }\n\n  /**\n   * @param {string} key\n   * @param {unknown} previousValue\n   * @param {unknown} nextValue\n   */\n  _assertSameValueDifferentReference(key, previousValue, nextValue) {\n    if (this.cfg.debug) {\n      if (nextValue !== previousValue && typeof nextValue === 'object' && typeof previousValue === 'object' && JSON.stringify(nextValue) === JSON.stringify(previousValue)) {\n        console.warn(`[uc-config] Option \"${key}\" value is the same as the previous one but the reference is different`);\n        console.warn(`[uc-config] You should avoid changing the reference of the object to prevent unnecessary calculations`);\n        console.warn(`[uc-config] \"${key}\" previous value:`, previousValue);\n        console.warn(`[uc-config] \"${key}\" new value:`, nextValue);\n      }\n    }\n  }\n  initCallback() {\n    super.initCallback();\n    const anyThis = /** @type {typeof this & any} */this;\n\n    // Subscribe to the state changes and update the local properties and attributes.\n    // Initial callback call is disabled to prevent the initial value to be set here.\n    // Initial value will be set below, skipping the default values.\n    for (const key of plainConfigKeys) {\n      this.sub(sharedConfigKey(key), value => {\n        this._setValue(key, value);\n      }, false);\n    }\n    for (const key of allConfigKeys) {\n      // Flush the initial value to the state.\n      // Initial value is taken from the DOM property if it was set before the element was initialized.\n      // If no DOM property was set, the initial value is taken from the initialConfig.\n      const initialValue = anyThis[key] ?? this.$[sharedConfigKey(key)];\n      if (initialValue !== initialConfig[key]) {\n        this._setValue(key, initialValue);\n      }\n\n      // Define DOM property setters and getters\n      // They will be used in the userland directly or by the frameworks\n      Object.defineProperty(this, key, {\n        /** @param {unknown} value */\n        set: value => {\n          this._setValue(key, value);\n        },\n        get: () => {\n          return this._getValue(key);\n        }\n      });\n      runSideEffects({\n        key,\n        setValue: this._setValue.bind(this),\n        getValue: this._getValue.bind(this)\n      });\n    }\n  }\n\n  /**\n   * @param {keyof typeof attrStateMapping} name\n   * @param {string} oldVal\n   * @param {string} newVal\n   */\n  attributeChangedCallback(name, oldVal, newVal) {\n    if (oldVal === newVal) return;\n    const anyThis = /** @type {typeof this & any} */this;\n    const key = attrKeyMapping[name];\n    // attributeChangedCallback could be called before the initCallback\n    // so we set the DOM property instead of calling this._setValue.\n    // If the block was initialized, the value will be handled by the setter.\n    // If the block was not initialized, the value will be set to the DOM property\n    // and handled on initialization.\n    anyThis[key] = newVal;\n  }\n}\nConfigClass.bindAttributes(attrStateMapping);\n\n/**\n * Define empty DOM properties for all config keys on the Custom Element class prototype to make them checkable using\n * `key in element` syntax. This is required for the frameworks DOM property bindings to work.\n */\nfor (const key of allConfigKeys) {\n  /** @type {any} */ConfigClass.prototype[key] = undefined;\n}\n\n/** @typedef {import('../../utils/mixinClass.js').MixinClass<typeof ConfigClass, import('../../types').ConfigType>} Config */\n\n// This is workaround for jsdoc that allows us to export extended class type along with the class itself\nexport const Config = /** @type {Config} */ /** @type {unknown} */ConfigClass;","map":{"version":3,"names":["Block","initialConfig","sharedConfigKey","toKebabCase","normalizeConfigValue","runAssertions","runSideEffects","allConfigKeys","Set","Object","keys","complexConfigKeys","isComplexKey","key","includes","plainConfigKeys","filter","attrKeyMapping","fromEntries","map","toLowerCase","attrStateMapping","getLocalPropName","ConfigClass","requireCtxName","constructor","init$","entries","value","_flushValueToAttribute","attrs","attr","removeAttribute","getAttribute","toString","setAttribute","_flushValueToState","$","_setValue","anyThis","normalizedValue","localPropName","_assertSameValueDifferentReference","debugPrint","cfg","setValue","bind","getValue","_getValue","previousValue","nextValue","debug","JSON","stringify","console","warn","initCallback","sub","initialValue","defineProperty","set","get","attributeChangedCallback","name","oldVal","newVal","bindAttributes","prototype","undefined","Config"],"sources":["/Users/kavinth/Documents/GitHub/Smart-Alert/Smart-Alert-new/frontend/node_modules/@uploadcare/file-uploader/blocks/Config/Config.js"],"sourcesContent":["// @ts-check\nimport { Block } from '../../abstract/Block.js';\nimport { initialConfig } from './initialConfig.js';\nimport { sharedConfigKey } from '../../abstract/sharedConfigKey.js';\nimport { toKebabCase } from '../../utils/toKebabCase.js';\nimport { normalizeConfigValue } from './normalizeConfigValue.js';\nimport { runAssertions } from './assertions.js';\nimport { runSideEffects } from './side-effects.js';\n\nconst allConfigKeys = /** @type {(keyof import('../../types').ConfigType)[]} */ ([\n  // \"debug\" option should go first to be able to print debug messages from the very beginning\n  ...new Set(['debug', ...Object.keys(initialConfig)]),\n]);\n\n/**\n * Config keys that can't be passed as attribute (because they are object or function)\n *\n * @type {[\n *   'metadata',\n *   'localeDefinitionOverride',\n *   'secureUploadsSignatureResolver',\n *   'secureDeliveryProxyUrlResolver',\n *   'iconHrefResolver',\n *   'fileValidators',\n *   'collectionValidators',\n *   'mediaRecorderOptions',\n * ]}\n */\nexport const complexConfigKeys = [\n  'metadata',\n  'localeDefinitionOverride',\n  'secureUploadsSignatureResolver',\n  'secureDeliveryProxyUrlResolver',\n  'iconHrefResolver',\n  'fileValidators',\n  'collectionValidators',\n  'mediaRecorderOptions',\n];\n\n/** @type {(key: keyof import('../../types').ConfigType) => key is keyof import('../../types').ConfigComplexType} */\nconst isComplexKey = (key) => complexConfigKeys.includes(key);\n\n/** Config keys that can be passed as attribute */\nconst plainConfigKeys = /** @type {(keyof import('../../types').ConfigPlainType)[]} */ (\n  allConfigKeys.filter((key) => !isComplexKey(key))\n);\n\n/**\n * Mapping of attribute names to config keys Kebab-case and lowercase are supported. lowercase could be used by\n * frameworks like vue and react.\n */\nconst attrKeyMapping =\n  /** @type {Record<keyof import('../../types').ConfigAttributesType, keyof import('../../types').ConfigPlainType>} */ ({\n    ...Object.fromEntries(plainConfigKeys.map((key) => [toKebabCase(key), key])),\n    ...Object.fromEntries(plainConfigKeys.map((key) => [key.toLowerCase(), key])),\n  });\n\n/** Mapping of attribute names to state */\nconst attrStateMapping = /** @type {Record<keyof import('../../types').ConfigAttributesType, string>} */ ({\n  ...Object.fromEntries(plainConfigKeys.map((key) => [toKebabCase(key), sharedConfigKey(key)])),\n  ...Object.fromEntries(plainConfigKeys.map((key) => [key.toLowerCase(), sharedConfigKey(key)])),\n});\n\n/** @param {string} key */\nconst getLocalPropName = (key) => '__' + key;\n\nclass ConfigClass extends Block {\n  requireCtxName = true;\n\n  constructor() {\n    super();\n\n    /** @type {Block['init$'] & import('../../types').ConfigType} */\n    this.init$ = {\n      ...this.init$,\n      ...Object.fromEntries(\n        Object.entries(initialConfig).map(([key, value]) => [\n          sharedConfigKey(/** @type {keyof import('../../types').ConfigType} */ (key)),\n          value,\n        ]),\n      ),\n    };\n  }\n\n  /**\n   * @private\n   * @param {keyof import('../../types').ConfigType} key\n   * @param {unknown} value\n   */\n  _flushValueToAttribute(key, value) {\n    if (plainConfigKeys.includes(key)) {\n      // Flush the value to the DOM attributes\n      const attrs = [...new Set([toKebabCase(key), key.toLowerCase()])];\n      for (const attr of attrs) {\n        if (typeof value === 'undefined' || value === null) {\n          this.removeAttribute(attr);\n        } else if (this.getAttribute(attr) !== value.toString()) {\n          this.setAttribute(attr, value.toString());\n        }\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {keyof import('../../types').ConfigType} key\n   * @param {unknown} value\n   */\n  _flushValueToState(key, value) {\n    if (this.$[sharedConfigKey(key)] !== value) {\n      if (typeof value === 'undefined' || value === null) {\n        this.$[sharedConfigKey(key)] = initialConfig[key];\n      } else {\n        this.$[sharedConfigKey(key)] = value;\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {keyof import('../../types').ConfigType} key\n   * @param {unknown} value\n   */\n  _setValue(key, value) {\n    const anyThis = /** @type {typeof this & any} */ (this);\n\n    const normalizedValue = normalizeConfigValue(key, value);\n\n    const localPropName = getLocalPropName(key);\n    if (anyThis[localPropName] === normalizedValue) return;\n\n    this._assertSameValueDifferentReference(key, anyThis[localPropName], normalizedValue);\n\n    anyThis[localPropName] = normalizedValue;\n\n    // Flush the value to the state\n    this._flushValueToAttribute(key, normalizedValue);\n    this._flushValueToState(key, normalizedValue);\n\n    this.debugPrint(`[uc-config] \"${key}\"`, normalizedValue);\n\n    runAssertions(this.cfg);\n    runSideEffects({\n      key,\n      setValue: this._setValue.bind(this),\n      getValue: this._getValue.bind(this),\n    });\n  }\n\n  /**\n   * @private\n   * @param {keyof import('../../types').ConfigType} key\n   */\n  _getValue(key) {\n    const anyThis = /** @type {typeof this & any} */ (this);\n    const localPropName = getLocalPropName(key);\n    return anyThis[localPropName] ?? this.$[sharedConfigKey(key)];\n  }\n\n  /**\n   * @param {string} key\n   * @param {unknown} previousValue\n   * @param {unknown} nextValue\n   */\n  _assertSameValueDifferentReference(key, previousValue, nextValue) {\n    if (this.cfg.debug) {\n      if (\n        nextValue !== previousValue &&\n        typeof nextValue === 'object' &&\n        typeof previousValue === 'object' &&\n        JSON.stringify(nextValue) === JSON.stringify(previousValue)\n      ) {\n        console.warn(\n          `[uc-config] Option \"${key}\" value is the same as the previous one but the reference is different`,\n        );\n        console.warn(\n          `[uc-config] You should avoid changing the reference of the object to prevent unnecessary calculations`,\n        );\n        console.warn(`[uc-config] \"${key}\" previous value:`, previousValue);\n        console.warn(`[uc-config] \"${key}\" new value:`, nextValue);\n      }\n    }\n  }\n\n  initCallback() {\n    super.initCallback();\n    const anyThis = /** @type {typeof this & any} */ (this);\n\n    // Subscribe to the state changes and update the local properties and attributes.\n    // Initial callback call is disabled to prevent the initial value to be set here.\n    // Initial value will be set below, skipping the default values.\n    for (const key of plainConfigKeys) {\n      this.sub(\n        sharedConfigKey(key),\n        (value) => {\n          this._setValue(key, value);\n        },\n        false,\n      );\n    }\n\n    for (const key of allConfigKeys) {\n      // Flush the initial value to the state.\n      // Initial value is taken from the DOM property if it was set before the element was initialized.\n      // If no DOM property was set, the initial value is taken from the initialConfig.\n      const initialValue = anyThis[key] ?? this.$[sharedConfigKey(key)];\n      if (initialValue !== initialConfig[key]) {\n        this._setValue(key, initialValue);\n      }\n\n      // Define DOM property setters and getters\n      // They will be used in the userland directly or by the frameworks\n      Object.defineProperty(this, key, {\n        /** @param {unknown} value */\n        set: (value) => {\n          this._setValue(key, value);\n        },\n        get: () => {\n          return this._getValue(key);\n        },\n      });\n\n      runSideEffects({\n        key,\n        setValue: this._setValue.bind(this),\n        getValue: this._getValue.bind(this),\n      });\n    }\n  }\n\n  /**\n   * @param {keyof typeof attrStateMapping} name\n   * @param {string} oldVal\n   * @param {string} newVal\n   */\n  attributeChangedCallback(name, oldVal, newVal) {\n    if (oldVal === newVal) return;\n\n    const anyThis = /** @type {typeof this & any} */ (this);\n    const key = attrKeyMapping[name];\n    // attributeChangedCallback could be called before the initCallback\n    // so we set the DOM property instead of calling this._setValue.\n    // If the block was initialized, the value will be handled by the setter.\n    // If the block was not initialized, the value will be set to the DOM property\n    // and handled on initialization.\n    anyThis[key] = newVal;\n  }\n}\n\nConfigClass.bindAttributes(attrStateMapping);\n\n/**\n * Define empty DOM properties for all config keys on the Custom Element class prototype to make them checkable using\n * `key in element` syntax. This is required for the frameworks DOM property bindings to work.\n */\nfor (const key of allConfigKeys) {\n  /** @type {any} */ (ConfigClass.prototype)[key] = undefined;\n}\n\n/** @typedef {import('../../utils/mixinClass.js').MixinClass<typeof ConfigClass, import('../../types').ConfigType>} Config */\n\n// This is workaround for jsdoc that allows us to export extended class type along with the class itself\nexport const Config = /** @type {Config} */ (/** @type {unknown} */ (ConfigClass));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}